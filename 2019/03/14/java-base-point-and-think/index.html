<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="有时候走了太久太远，都忘了为什么出发了。 面向过程和面向对象 面向过程 概：面向对象在我印象里是最初在C中获得的，注重顺序思维，结构化编程，即使封装函数也是为了复用，而不是降低耦合。 优点：比面向对象性能更好，不用实例化，节省资源。性能因素占绝对重要性时，优考虑面向过程的开发。 缺点：流式思维，不符合客观世界规律，比起面向对象，更难维护、复用和、扩展。   面向对象： 概：是现实世界关系的抽象，符">
<meta property="og:type" content="article">
<meta property="og:title" content="java base point and think">
<meta property="og:url" content="http://yoursite.com/2019/03/14/java-base-point-and-think/index.html">
<meta property="og:site_name" content="华氏温度">
<meta property="og:description" content="有时候走了太久太远，都忘了为什么出发了。 面向过程和面向对象 面向过程 概：面向对象在我印象里是最初在C中获得的，注重顺序思维，结构化编程，即使封装函数也是为了复用，而不是降低耦合。 优点：比面向对象性能更好，不用实例化，节省资源。性能因素占绝对重要性时，优考虑面向过程的开发。 缺点：流式思维，不符合客观世界规律，比起面向对象，更难维护、复用和、扩展。   面向对象： 概：是现实世界关系的抽象，符">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-03-14T07:50:00.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java base point and think">
<meta name="twitter:description" content="有时候走了太久太远，都忘了为什么出发了。 面向过程和面向对象 面向过程 概：面向对象在我印象里是最初在C中获得的，注重顺序思维，结构化编程，即使封装函数也是为了复用，而不是降低耦合。 优点：比面向对象性能更好，不用实例化，节省资源。性能因素占绝对重要性时，优考虑面向过程的开发。 缺点：流式思维，不符合客观世界规律，比起面向对象，更难维护、复用和、扩展。   面向对象： 概：是现实世界关系的抽象，符">






  <link rel="canonical" href="http://yoursite.com/2019/03/14/java-base-point-and-think/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>java base point and think | 华氏温度</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">华氏温度</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Startseite</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />Über</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />Tags</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />Kategorien</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archiv</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/14/java-base-point-and-think/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Howard">
      <meta itemprop="description" content="午夜向日葵，晌午夜光杯。跛者脚下路，屠夫腕上佛。">
      <meta itemprop="image" content="/images/avatar/P1070776.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="华氏温度">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">java base point and think
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2019-03-14 15:50:00" itemprop="dateCreated datePublished" datetime="2019-03-14T15:50:00+08:00">2019-03-14</time>
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/03/14/java-base-point-and-think/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/03/14/java-base-point-and-think/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="有时候走了太久太远，都忘了为什么出发了。"><a href="#有时候走了太久太远，都忘了为什么出发了。" class="headerlink" title="有时候走了太久太远，都忘了为什么出发了。"></a>有时候走了太久太远，都忘了为什么出发了。</h4><ol>
<li>面向过程和面向对象<ol>
<li>面向过程<ol>
<li>概：面向对象在我印象里是最初在C中获得的，注重顺序思维，结构化编程，即使封装<br>函数也是为了复用，而不是降低耦合。</li>
<li>优点：比面向对象性能更好，不用实例化，节省资源。性能因素占绝对重要性时，<br>优考虑面向过程的开发。</li>
<li>缺点：流式思维，不符合客观世界规律，比起面向对象，更难维护、复用和、扩展。</li>
</ol>
</li>
<li>面向对象：<ol>
<li>概：是现实世界关系的抽象，符合现实世界的逻辑规律。</li>
<li>优点：抑郁维护复用和扩展。有封装、继承和多态的特性。</li>
<li>缺点：资源开销大，性能比面向过程差。</li>
</ol>
</li>
<li>言之： 现在除了特别对性能有要求的一些项目，对于更多的业务系统讲，机器资源一般是<br>较为满足的，更注重的是易维护，易扩展，业务系统大概占据了软件开发项目八成，所以在业务系统上，<br>采用面向对象的方式进行开发。（现在的互联网行业人员流动那么大，程序员的编程水平习惯参差不齐，<br>如果还不注重维护性和扩展性的话，那大概就是前人挖坑闪后人，后人再挖，闪后后人，<br>子子孙孙无穷匮也。）</li>
</ol>
</li>
<li><p>Java的特点</p>
<ol>
<li>优点：<ol>
<li>学习成本底。（相比C和C++吧，比Python还差些 :smile:）</li>
<li>面向对象。（C++也是面向对象的，严格的说面向对象是一种思想）</li>
<li>平台无关。可移植性好。（只要这个平台有对应的jvm，你只管敲你的Java代码，<br>编译成class后，jvm去生产适配各个平台的机器指令。）</li>
<li>可靠性。（因为强类型？怎么就比其他语言更可靠了？质疑）</li>
<li>安全性。（和强类型有关，也没有C里指针的各种乱指）</li>
<li>多线程支持。（C++没有内置的对多线程的支持，需要调用系统的多线程支持）</li>
<li>方便的网络编程。（简化了网络编程是指对JavaWeb方向的扩展么？确实在C里网络编程中的<br>通信一些东西确实比较复杂。）</li>
<li>编译与解释并存。（Java确实从解释语言里学了很多，这点是我很欣赏的，知道发展自身，<br>才是生存下去的道理。）</li>
</ol>
</li>
<li>缺点：<ol>
<li>初期性能经常与C系比较，确实差一些，但是现在的java性能已经不能被诟病了。<br>2.</li>
</ol>
</li>
</ol>
</li>
<li><p>JVM JDK JRE</p>
<ol>
<li>JVM（Java Virtual Machine）<ul>
<li>运行java字节码，字节码class文件jvm能理解</li>
<li>对不同系统有不同实现</li>
<li>class文件只面向jvm，各个平台上都是一样的</li>
<li>一方面解决了解释型语言效率低问题</li>
<li>保留了解释性语言可移植性</li>
<li>在不同平台上不需要重新编译，可以直接运行</li>
<li>.java文件  – jdk中的javac –&gt; .class文件</li>
<li>.class文件  – jvm –&gt; 二进制机器码。jvm类加载器首先加载字节码文件，<br>解释器逐行解释执行。但是热点代码会多次被解释，所以引进了JIM(Just In Time)编译器。<br>运行时编译器，完成一次编译以后，字节码对应的机器码保存，下次调用到直接使用。<br>这一部分属于编译后调用，每次重新编译的是解释的部分。</li>
<li>HotSpot 惰性评估(Lazy Evaluation)  热点代码是需要JIT编译的部分<br>JVM根据每次执行的情况收集信息并且相应的优化 执行次数越多，速度越快<br>JDK9引入AOT(Ahead of Time Compilation)编译，直接将字节码编译成机器码，<br>避免了JIT模式下的预热开销。</li>
<li>支持分层编译和AOT协作使用 <code>？？？</code>   AOT编译质量不如JIT<code>？？？</code></li>
<li>字节码 和 不同系统的JVM实现 保证了一次编译到处运行</li>
</ul>
</li>
<li>JDK<ul>
<li>Java Development Kit</li>
<li>包括JRE</li>
<li>编译器</li>
<li>其他工具</li>
</ul>
</li>
<li>JRE<ul>
<li>Java Runtime Environment</li>
<li>运行已编译java程序</li>
<li>包括jvm java类库 java命令 其他基础构件</li>
<li>包含jsp的web程序，也需要jdk，因为需要将JSP转换为Java servlet，需要jsk编译servlet。</li>
</ul>
</li>
</ol>
</li>
<li><p>Oracle JDK 和 OpenJDK</p>
<ol>
<li>Oracle JDK<ul>
<li>不是完全开源的</li>
<li>更稳定，优化更多，效率可能更高？</li>
</ul>
</li>
<li>OpenJDK<ul>
<li>开源</li>
<li>GPL许可协议</li>
</ul>
</li>
</ol>
</li>
<li><p>Java和C++的区别</p>
<ol>
<li>共通：面向对象，支持继承封装和多态</li>
<li>java: 不提供指针访问内存，更安全   类单继承   接口多继承  内存管理机制</li>
<li>C++： 提供指针   类可以多继承   需要程序员释放内存</li>
</ol>
</li>
<li><p>字符型常量和字符串常量的区别<br> 1.</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">'c'</span>;  String s = <span class="string">"sss"</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>字符相当于ascII值，可以参加运算。字符串代表地址，即在内存中存放位置。</li>
<li>char类型占2个字节 2*8bit = 16bit；字符串至少一个，结束标志（这句并不对，<br>在C++中，以\0作为结束，但是在Java中，String是对象，有长度属性，不需要表示结尾）</li>
</ol>
</li>
<li><p>构造器 Constructor 是否可被 override</p>
<ul>
<li>父类的私有属性和构造方法并不能被继承</li>
<li>Constructor 也就不能被 override（重写）</li>
<li>可以overload（重载）</li>
</ul>
</li>
<li><p>Java 面向对象编程三大特性: 封装 继承 多态</p>
<ol>
<li>封装把对象属性私有化，提供可以被外界访问的属性的方法，<br>可不提供，但是如果一个类没有提供给外界访问的方法，那这个类也没有什么意义了。</li>
<li>继承是使用已存在的类的定义作为基础建立新类的技术，<br>新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。<br>通过使用继承能复用以前的代码。</li>
<li><ul>
<li>子类有父类非private属性和方法<ul>
<li>子类可以有自己的属性和方法</li>
<li>子类可以重写父类非private方法（构造方法呢？基于自己的+super()）</li>
</ul>
</li>
</ul>
</li>
<li>多态指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用，<br>在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，<br>该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。<ul>
<li>继承实现（多个子类对同一方法的重写）</li>
<li>接口实现（实现接口并覆盖接口中同一方法）。</li>
</ul>
</li>
</ol>
</li>
<li><p>String StringBuffer 和 StringBuilder</p>
<ol>
<li>可变性<ul>
<li>String -&gt; private final char value[];  不可变</li>
<li>StringBuilder 与 StringBuffer 都继承AbstractStringBuilder    char[] value; 可变</li>
</ul>
</li>
<li>线程安全性<ul>
<li>String final 常量线程安全</li>
<li>StringBuilder 没有对方法加同步锁，非线程安全</li>
<li>StringBuffer  加了同步锁，线程安全  ，内部使用 synchronized 进行同步</li>
</ul>
</li>
<li>性能<ul>
<li>对String变量改变赋值，生成新String对象，指针指向新的String对象</li>
<li>StringBuffer每次操作自己</li>
<li>StringBuilder 有更高的性能</li>
</ul>
</li>
<li>少量数据为了方便直接String   操作大量数据 单线程StringBuilder  多线程StringBuffer</li>
</ol>
</li>
<li><p>在一个静态方法内调用一个非静态成员为什么是非法的</p>
<ul>
<li>静态方法不通过对象去调用方法</li>
</ul>
</li>
<li><p>在 Java 中定义一个不做事且没有参数的构造方法的作用</p>
<ul>
<li>继承 子类中的super() 调用父类中无参数构造函数 如果出现这种情况，而父类中没有，报错</li>
</ul>
</li>
<li><p>import java和javax有什么区别</p>
<ul>
<li>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来说使用。</li>
<li>然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部分。</li>
<li>但是，将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏一堆现有的代码。</li>
<li>因此，最终决定 javax 包将成为标准API的一部分。</li>
<li>所以，实际上java和javax没有区别。这都是一个名字。</li>
</ul>
</li>
<li><p>接口和抽象类的区别是什么</p>
<ol>
<li>接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），抽象类可以有非抽象的方法实现</li>
<li>接口中的实例变量默认是 final 类型的，而抽象类中则不一定</li>
<li>一个类可以实现多个接口，但最多只能实现一个抽象类(java中接口和继承的区别)</li>
<li>一个类实现接口的话要实现接口的所有方法，而抽象类不一定(不实现默认使用父类)</li>
<li>接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象<br>从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</li>
</ol>
</li>
<li><p>成员变量与局部变量的区别有那些</p>
<ol>
<li>从语法形式上<ul>
<li>看成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数</li>
<li>成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；</li>
<li>成员变量和局部变量都能被 final 所修饰；</li>
</ul>
</li>
<li>从变量在内存中的存储方式来看<ul>
<li>如果成员变量是使用static修饰的，那么这个成员变量是属于类的</li>
<li>如果没有使用使用static修饰，这个成员变量是属于实例的。</li>
<li>而对象存在于堆内存，局部变量存在于栈内存</li>
</ul>
</li>
<li>从变量在内存中的生存时间上看<ul>
<li>成员变量是对象的一部分，它随着对象的创建而存在</li>
<li>局部变量随着方法的调用而自动消失。</li>
</ul>
</li>
<li>成员变量如果没有被赋初值<ul>
<li>则会自动以类型的默认值而赋值(一种情况例外被 final 修饰的成员变量也必须显示地赋值)</li>
<li>局部变量则不会自动赋值。</li>
</ul>
</li>
</ol>
</li>
<li><p>创建一个对象用什么运算符?对象实体与对象引用有何不同?</p>
<ul>
<li>new运算符，new创建对象实例（对象实例在堆内存中）</li>
<li>对象引用指向对象实例（对象引用存放在栈内存中）</li>
<li>一个对象引用可以指向0个或1个对象（一根绳子可以不系气球null，也可以系一个气球）</li>
<li>一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）获取同一个对象</li>
</ul>
</li>
<li><p>构造方法特性</p>
<ul>
<li>名字与类名相同</li>
<li>没有返回值，但不能用void声明</li>
<li>生成类的对象自动执行，无需调用</li>
</ul>
</li>
<li><p>静态方法和实例方法有何不同</p>
<ul>
<li>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式，<br>调用静态方法可以无需创建对象。静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），<br>而不允许访问实例成员变量和实例方法.</li>
<li>实例方法只有”对象名.方法名”的方式，实例方法可以访问所有成员和方法</li>
</ul>
</li>
<li><p>在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是帮助子类做初始化工作。</p>
</li>
<li><p>== 与 equals</p>
<ol>
<li>==<ul>
<li>它的作用是判断两个对象的地址是不是相等，两个对象是不是同一个对象。</li>
<li>基本数据类型==比较的是值，引用数据类型==比较的是内存地址</li>
</ul>
</li>
<li>equals()<ul>
<li>类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li>
<li>类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；<br>若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li>
<li>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，<br>而 String 的 equals 方法比较的是对象的值。</li>
<li>创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，<br>如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li>
</ul>
</li>
</ol>
</li>
<li><p>hashCode 与 equals</p>
<ol>
<li>hashCode<ul>
<li>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。</li>
<li>这个哈希码的作用是确定该对象在哈希表中的索引位置。</li>
<li>hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。</li>
<li>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。<br>这其中就利用到了散列码！（可以快速找到所需要的对象）</li>
</ul>
</li>
<li>为什么要有 hashCode<ul>
<li>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，<br>同时也会与其他已经加入的对象的 hashcode 值作比较</li>
<li>如果没有相符的hashcode，HashSet会假设对象没有重复出现。</li>
<li>但是如果发现有相同 hashcode 值的对象，这时会调用 equals（）方法来检查 hashcode 相等的对象是否真的相同。</li>
<li>如果两者相同，HashSet 就不会让其加入操作成功。</li>
<li>如果不同的话，就会重新散列到其他位置。</li>
<li>大大减少了 equals 的次数，相应就大大提高了执行速度。</li>
</ul>
</li>
<li>hashCode（）与equals（）的相关规定<ul>
<li>如果两个对象相等，则hashcode一定也是相同的</li>
<li>两个对象相等,对两个对象分别调用equals方法都返回true</li>
<li>两个对象有相同的hashcode值，它们也不一定是相等的</li>
<li>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</li>
<li>hashCode() 的默认行为是对堆上的对象产生独特值。<br>如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ul>
</li>
</ol>
</li>
<li><p>为什么Java中只有值传递</p>
<ul>
<li>基本类型值，将值拷贝，进行值传递。对象传递的话，将对象的引用（地址）拷贝，进行值传递。<br>但是地址的copy值指向同一个对象，方法对对象成员的改动，即改动了对象在内存里的值，会反映在外部。<br>然而，如果直接换引用，是换了copy的引用，和外部原来的引用并没有关系。</li>
</ul>
</li>
<li><p>线程,程序,进程的基本概念</p>
<ol>
<li>线程<ul>
<li>与进程相似，比进程更小的执行单位。</li>
<li>一个进程在其执行的过程中可以产生多个线程。</li>
<li>与进程不同，多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，<br>或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li>
</ul>
</li>
<li>程序<ul>
<li>含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中</li>
<li>程序是静态的代码。</li>
</ul>
</li>
<li>进程<ul>
<li>是程序的一次执行过程，是系统运行程序的基本单位，进程是动态的。</li>
<li>系统运行一个程序即是一个进程从创建，运行到消亡的过程。</li>
<li>一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，<br>每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等。</li>
<li>当程序在执行时，将会被操作系统载入内存中。</li>
<li>线程是进程划分成的更小的运行单位。</li>
<li>线程和进程最大的不同在于，基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。</li>
<li>进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，<br>而线程则是在同一程序内几乎同时执行一个以上的程序段。</li>
</ul>
</li>
</ol>
</li>
<li><p>线程基本状态</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>状态名称</th>
<th>Point</th>
</tr>
</thead>
<tbody>
<tr>
<td>NEW</td>
<td>初始状态，已经构建，没有调用start()方法</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>运行状态，就绪状态(调用start()方法，但还没有run) 　+　运行中状态</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>阻塞状态，阻塞于锁？</td>
</tr>
<tr>
<td>WAITING</td>
<td>等待状态，需要其他线程通知或者中断</td>
</tr>
<tr>
<td>TIME_WAITING</td>
<td>超时等待状态，指定时间自行返回</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>终止线程，执行完毕</td>
</tr>
</tbody>
</table>
<ol start="24">
<li><p>final</p>
<ol>
<li>变量<ul>
<li>基本数据类型在初始化之后便不能更改</li>
<li>引用类型初始化之后便不能再让其指向另一个对象</li>
</ul>
</li>
<li>类<ul>
<li>类不能被继承。</li>
<li>final类中的所有成员方法都会被隐式地指定为final方法。</li>
</ul>
</li>
<li>方法<ul>
<li>方法锁定，以防任何继承类修改它的含义</li>
<li>早期的Java实现版本中，会将final方法转为内嵌调用。<br>但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升<br>（现在的Java版本已经不需要使用final方法进行这些优化了）。</li>
<li>类中所有的private方法都隐式地指定为final。</li>
</ul>
</li>
</ol>
</li>
<li><p>异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">  Throwable--&gt;Error;</span><br><span class="line">  Throwable--&gt;Exception;</span><br><span class="line">  Error--&gt;VirtulMachineError;</span><br><span class="line">  Error--&gt;AWTError;</span><br><span class="line">  VirtulMachineError--&gt;StackOverFlowError;</span><br><span class="line">  VirtulMachineError--&gt;OutOfMemoryError;</span><br><span class="line">  Exception--&gt;IOException;</span><br><span class="line">  Exception--&gt;RuntimeException;</span><br><span class="line">  IOException--&gt;EOFException;</span><br><span class="line">  IOException--&gt;FileNotFoundException;</span><br><span class="line">  RuntimeException--&gt;ArrithmeticException;</span><br><span class="line">  RuntimeException--&gt;MissingResourceException;</span><br><span class="line">  RuntimeException--&gt;ClassNotFoundException;</span><br><span class="line">  RuntimeException--&gt;NullPointerException;</span><br><span class="line">  RuntimeException--&gt;IllegalArgumentException;</span><br><span class="line">  RuntimeException--&gt;ArrayIndexOutOfBoundsException;</span><br><span class="line">  RuntimeException--&gt;UnknownTypeException;</span><br></pre></td></tr></table></figure>
<ol>
<li>Error（错误）<ul>
<li>程序无法处理的错误，表示运行应用程序中较严重问题。</li>
<li>大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。<br>例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，<br>将出现 OutOfMemoryError。</li>
<li>Error发生时，Java虚拟机（JVM）一般会选择线程终止。<ul>
<li>这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，<br>如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。</li>
<li>错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。</li>
<li>对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。</li>
<li>在 Java中，错误通过Error的子类描述。</li>
</ul>
</li>
</ul>
</li>
<li>Exception（异常）<ul>
<li>程序本身可以处理的异常。</li>
<li>RuntimeException异常由Java虚拟机抛出。<br>NullPointerException（要访问的变量没有引用任何对象时，抛出该异常）,<br>ArithmeticException（算术运算异常，一个整数除以0时，抛出该异常）,<br>ArrayIndexOutOfBoundsException （下标越界异常）。</li>
</ul>
</li>
</ol>
<p><strong>异常能被程序本身可以处理，错误无法处理。</strong></p>
<ol start="3">
<li><p>Throwable类常用方法</p>
<ul>
<li>public string getMessage():返回异常发生时的详细信息</li>
<li>public string toString():返回异常发生时的简要描述</li>
<li>public string getLocalizedMessage():返回异常对象的本地化信息。<br>使用Throwable的子类覆盖这个方法，可以声称本地化信息。<br>如果子类没有覆盖该方法，则该方法返回的信息与getMessage（）返回的结果相同</li>
<li>public void printStackTrace():在控制台上打印Throwable对象封装的异常信息</li>
</ul>
</li>
<li><p>异常处理总结</p>
<ul>
<li><strong>try块：</strong> 用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。</li>
<li><strong>catch 块：</strong> 用于处理try捕获到的异常。</li>
<li><p><strong>inally 块：</strong> 无论是否捕获或处理异常，finally块里的语句都会被执行。<br>当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。</p>
</li>
<li><p><strong><em>finally块不会被执行</em></strong></p>
<ul>
<li>在finally语句块第一行发生了异常。 因为在其他行，finally块还是会得到执行</li>
<li>在前面的代码中用了System.exit(int)已退出程序。 exit是带参函数 ；若该语句在异常语句之后，finally会执行</li>
<li>程序所在的线程死亡。(后面两个在逗我咩QAQ，这不废话么)</li>
<li>关闭CPU。</li>
</ul>
</li>
</ul>
</li>
<li><p>如果try语句里有return，返回的是try语句块中变量值。</p>
<ol>
<li>如果有返回值，就把返回值保存到局部变量中；</li>
<li>执行jsr指令跳到finally语句里执行；</li>
<li>执行完finally语句后，返回之前保存在局部变量表里的值。</li>
<li>如果try，finally语句里均有return，忽略try的return，而使用finally的return.</li>
</ol>
</li>
</ol>
</li>
<li><p>transient</p>
<ul>
<li>阻止实例中那些用此关键字修饰的的变量序列化；</li>
<li>当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复</li>
<li>transient只能修饰变量，不能修饰类和方法。</li>
</ul>
</li>
<li><p>console键盘输入</p>
<ul>
<li><p>通过 Scanner</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s  = input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 BufferedReader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s = input.readLine();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>数据类型</p>
<ol>
<li><p>基本类型</p>
<p>|keyWord|package|size|range|default|<br>|—|—|—|—|—|<br>|boolean|Boolean|1byte字节、8bit位|true，false JVM 会在编译时期将 boolean 类型的数据转换为 int，1 true，0 false|false|<br>|byte|Byte|1byte字节、8bit位|能存256个数，正负各128个，0放在正数一半 –&gt; -128~127|0|<br>|char|Character|2byte字节、16bit位|能存65536个，对应Ascii码表，不需要负数，0~65535|’\u0000’|<br>|short|Short|2byte字节、16bit位|能存65536个数，正负各32768个,0放正数一半 –&gt; -32768~32767|0|<br>|int|Integer|4byte字节、32bit位|能存4294967296个数，正负各2147483648个,0放正数一半 –&gt; -2147483648~2147483647|0|<br>|long|Long|8byte字节、64bit位|能存4294967296个数，正负各一半,0放正数一半 –&gt; 9223372036854775808~9223372036854775807|0L|<br>|float|Float|4byte字节、32bit位|符号位（sign）占用1位，用来表示正负数，指数位（exponent）占用8位，用来表示指数，小数位（fraction）占用23位，用来表示小数，不足位数补0。|0.0F|<br>|double|Double|8byte字节、64bit位|符号位（sign）占用1位，指数位（exponent）占用11位，小数位（fraction）占用52位，不足位数补0。|0.0D|</p>
</li>
</ol>
</li>
</ol>
<pre><code>2. 包装类型
    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="number">2</span>;     <span class="comment">// 装箱</span></span><br><span class="line"><span class="keyword">int</span> y = x;         <span class="comment">// 拆箱</span></span><br></pre></td></tr></table></figure>

3. 缓存池
    - new Integer(123) 每次都会新建一个对象；
    - Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。
    - 先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。
    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    - 自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，
    那么就会引用相同的对象。
    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer m = <span class="number">123</span>;</span><br><span class="line">Integer n = <span class="number">123</span>;</span><br><span class="line">System.out.println(m == n); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><ol start="2">
<li><p>String</p>
<ol>
<li>概：<ul>
<li>final 不可被继承。</li>
<li>Java 8 内部使用 char 数组存储数据</li>
<li>Java 9 改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。</li>
</ul>
</li>
<li><p>不可变的好处</p>
<ul>
<li>缓存 hash 值：因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。<br>不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</li>
<li>String Pool 的需要： 如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。<br>只有 String 是不可变的，才可能使用 String Pool。</li>
<li>安全性：String 经常作为参数，String 不可变性可以保证参数不可变。<br>例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，<br>改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</li>
<li>线程安全:</li>
</ul>
</li>
<li><p>String Pool</p>
<ul>
<li>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），<br>这些字面量在编译时期就确定。</li>
<li><p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等<br>（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；<br>否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false</span></span><br><span class="line">String s3 = s1.intern();</span><br><span class="line">String s4 = s1.intern();</span><br><span class="line">System.out.println(s3 == s4);           <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>采用字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s5 = <span class="string">"bbb"</span>;</span><br><span class="line">String s6 = <span class="string">"bbb"</span>;</span><br><span class="line">System.out.println(s5 == s6);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。<br>而在 Java 7，String Pool 被移到堆中。<br>这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p>
</li>
</ul>
</li>
<li><p>new String(“abc”)</p>
<ul>
<li>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量</li>
<li><p>而使用 new 的方式会在堆中创建一个字符串对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewStringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反编译得到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// ...</span><br><span class="line">Constant pool:</span><br><span class="line">// ...</span><br><span class="line">   #2 = Class              #18            // java/lang/String</span><br><span class="line">   #3 = String             #19            // abc</span><br><span class="line">// ...</span><br><span class="line">  #18 = Utf8               java/lang/String</span><br><span class="line">  #19 = Utf8               abc</span><br><span class="line">// ...</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=3, locals=2, args_size=1</span><br><span class="line">         0: new           #2                  // class java/lang/String</span><br><span class="line">         3: dup</span><br><span class="line">         4: ldc           #3                  // String abc</span><br><span class="line">         6: invokespecial #4                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">         9: astore_1</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure>
<p>在 Constant Pool 中，#19 存储这字符串字面量 “abc”，<br>#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。<br>在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，<br>并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。</p>
</li>
<li><p>String 构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.value = original.value;</span><br><span class="line"><span class="keyword">this</span>.hash = original.hash;</span><br></pre></td></tr></table></figure>
<p>将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>运算</p>
<ol>
<li>参数传递 都是值传递，对象也是地址当成值传递</li>
<li><p>float 与 double</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// float f = 1.1; //这个是把double赋值给了float，Java 不能隐式执行向下转型，因为这会使得精度降低。</span></span><br><span class="line"><span class="keyword">float</span> f = <span class="number">1.1f</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>隐式类型转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。</span></span><br><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// s1 = s1 + 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是使用 += 或者 ++ 运算符可以执行隐式类型转换。</span></span><br><span class="line">s1 += <span class="number">1</span>;</span><br><span class="line"><span class="comment">// s1++;</span></span><br><span class="line"></span><br><span class="line">s1 = (<span class="keyword">short</span>) (s1 + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>switch</p>
<ul>
<li>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</li>
<li>switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，<br>如果值过于复杂，那么还是用 if 比较合适。</li>
</ul>
</li>
</ol>
</li>
</ol>

      
    </div>

    

    
    
    

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/images/qrcode_for_gh.jpg" alt="Howard wechat" style="width: 200px; max-width: 100%;"/>
    <div>扫一下，看公众号刺激到随时怀孕~</div>
</div>

      </div>
    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>大爷，真是福寿延绵~再来玩~</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/reward/wechat.png" alt="Howard WeChat Pay"/>
        <p>WeChat Pay</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/reward/alipay.jpg" alt="Howard Alipay"/>
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/21/初始的springboot项目的依赖分析/" rel="next" title="初始的springboot项目的依赖分析">
                <i class="fa fa-chevron-left"></i> 初始的springboot项目的依赖分析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Übersicht
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar/P1070776.jpg"
                alt="Howard" />
            
              <p class="site-author-name" itemprop="name">Howard</p>
              <p class="site-description motion-element" itemprop="description">午夜向日葵，晌午夜光杯。跛者脚下路，屠夫腕上佛。</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">Artikel</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">Kategorien</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">11</span>
                    <span class="site-state-item-name">Tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/hizzyishome" target="_blank" title="GitHub" rel="external nofollow"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:hizzyzzh@hotmail.com" target="_blank" title="E-Mail" rel="external nofollow"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://mi.com/" title="MI" target="_blank">MI</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#有时候走了太久太远，都忘了为什么出发了。"><span class="nav-number">1.</span> <span class="nav-text">有时候走了太久太远，都忘了为什么出发了。</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Howard</span>

  

  
</div>


  



  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" rel="external nofollow" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" rel="external nofollow" href="https://theme-next.org">NexT.Gemini</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  



  
  



  
  



  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_sphere.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  

  
    <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
  

  
    <script type="text/javascript">
      var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2019/03/14/java-base-point-and-think/';
        this.page.identifier = '2019/03/14/java-base-point-and-think/';
        this.page.title = 'java base point and think';
        };
      function loadComments () {
        var d = document, s = d.createElement('script');
        s.src = 'https://.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      }
      
        $(function () {
          var offsetTop = $('#comments').offset().top - $(window).height();
          if (offsetTop <= 0) {
            // load directly when there's no a scrollbar
            loadComments();
          } else {
            $(window).on('scroll.disqus_scroll', function () {
              var scrollTop = document.documentElement.scrollTop;
              if (scrollTop >= offsetTop) {
                $(window).off('.disqus_scroll');
                loadComments();
              }
            });
          }
        });
      
    </script>
  





  





  










  





  

  

  

  
  

  
  

  


  
  

  

  

  

  

  

</body>
</html>
