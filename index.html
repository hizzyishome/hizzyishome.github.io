<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="午夜向日葵，晌午夜光杯。跛者脚下路，屠夫腕上佛。">
<meta property="og:type" content="website">
<meta property="og:title" content="华氏温度">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="华氏温度">
<meta property="og:description" content="午夜向日葵，晌午夜光杯。跛者脚下路，屠夫腕上佛。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="华氏温度">
<meta name="twitter:description" content="午夜向日葵，晌午夜光杯。跛者脚下路，屠夫腕上佛。">






  <link rel="canonical" href="http://yoursite.com/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>华氏温度</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">华氏温度</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Startseite</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />Über</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />Tags</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />Kategorien</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archiv</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/22/翻译-java-io教程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Howard">
      <meta itemprop="description" content="午夜向日葵，晌午夜光杯。跛者脚下路，屠夫腕上佛。">
      <meta itemprop="image" content="/images/avatar/P1070776.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="华氏温度">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/22/翻译-java-io教程/" itemprop="url">
                  [翻译]java io教程
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2020-02-22 11:11:15" itemprop="dateCreated datePublished" datetime="2020-02-22T11:11:15+08:00">2020-02-22</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/22/翻译-java-io教程/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/02/22/翻译-java-io教程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="toc"><a href="#toc" class="headerlink" title="[toc]"></a>[toc]</h2><blockquote><p>原文链接：<a href="http://tutorials.jenkov.com/java-io/index.html#java-io-api-scope" target="_blank" rel="noopener">http://tutorials.jenkov.com/java-io/index.html#java-io-api-scope</a></p>
</blockquote>
<p>Java IO 是java自带的为了读入和写出数据而设计的API.绝大所数应用需要进行输入操作然后基于输入数据生成输出数据.<br>例如:从文件或者网络上读取数据,相对应的,往文件中写入数据或者向网络写出返回一个响应.</p>
<p>Java IO API 位于 Java IO包中.如果你查看在java.io包中的Java IO相关类,繁杂大量的选择会让你迷茫于该选择哪一个来使用.<br>这些类的是为了应对什么场景?对于给定的特定任务,你应该选择哪一个?你如何创建适合自己业务场景的插件类?等等.</p>
<p>这个教程的目的是对这些IO类是如何组织,如何是使用的给你一个总体的把握.方便你选择正确的类处理对应的任务或者已经有了可以完美解决的类或方法.</p>
<p>A good place to start is the Java IO Overview tutorial. That tutorial gives you a quick overview of the central concepts<br>in the Java IO API, and an overview of all the central classes in the Java IO API.<br>本教程是你吃透Java IO的一个良好指导.教程将带你对JAVA IO API的核心概念和类以及方法,有一个全局的掌握.</p>
<h2 id="Java-IO包的作用域"><a href="#Java-IO包的作用域" class="headerlink" title="Java IO包的作用域"></a>Java IO包的作用域</h2><p>其实java.io包并没有包括全部类型的输入和输出.例如,从GUI程序或者Web网页的输入和输出就没有包含在java.io包中.这些类型的输入和输出被包含在其他<br>位置,比如GUI被包括在JFC类在Swing项目中,而Servle 和 HTTP 相关的在J2EE相关包中.</p>
<p>java.io包下的类和方法主要目的在处理文件的输入输出,网络上的流,内存缓冲区等.但是,java.io包不包括网络连接中必须的建立打开网络socket相关类.<br>由于这个原因,你需要使用Java Networking API.一旦你建立并打开了socke网络连接,之后对数据读写的操作都是通过java IO包中的InputStream类,<br>和OutputStream类.</p>
<h2 id="Java-NIO-——-另一种IO的选择"><a href="#Java-NIO-——-另一种IO的选择" class="headerlink" title="Java NIO —— 另一种IO的选择"></a>Java NIO —— 另一种IO的选择</h2><p>Java 也提供了另一种IO API叫做Java NIO。它包含的类和方法和Java IO以及Java Networking APIs提供的功能大致相同，但是Java NIO可以在<br><strong>非阻塞</strong>的模式下运行。非阻塞IO相比于阻塞IO在某些情况下会有大幅度的效率提升。</p>
<h2 id="更多javaIO的工具，技巧等"><a href="#更多javaIO的工具，技巧等" class="headerlink" title="更多javaIO的工具，技巧等"></a>更多javaIO的工具，技巧等</h2><p>本部分教程叫做java有妙招，java 有好物。也包含一些关于java io 的工具。例如：在Stream中替换String，用buffer遍历流等。</p>
<h2 id="Java-IO-类一览表"><a href="#Java-IO-类一览表" class="headerlink" title="Java IO 类一览表"></a>Java IO 类一览表</h2><p>下面列出的java io 类从输入，输出，以字符为单位，以字节为单位或者更多特定目的，比如缓存，解析等方面分门别类。  </p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:center">基于字符输入byte</th>
<th style="text-align:center">输出</th>
<th style="text-align:center">基于字符输入Character</th>
<th style="text-align:center">Output</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">基础（Basic）</td>
<td style="text-align:center">InputStream</td>
<td style="text-align:center">OutputStream</td>
<td style="text-align:center">Reader InputStreamReader</td>
<td style="text-align:center">Writer OutputStreamWriter</td>
</tr>
<tr>
<td style="text-align:left">数组（Arrays）</td>
<td style="text-align:center">ByteArrayInputStream</td>
<td style="text-align:center">ByteArrayOutputStream</td>
<td style="text-align:center">CharArrayReader</td>
<td style="text-align:center">CharArrayWriter</td>
</tr>
<tr>
<td style="text-align:left">文件（Files）</td>
<td style="text-align:center">FileInputStream RandomAccessFile</td>
<td style="text-align:center">FileOutputStream RandomAccessFile</td>
<td style="text-align:center">FileReader</td>
<td style="text-align:center">FileWriter</td>
</tr>
<tr>
<td style="text-align:left">管道（Pipes）</td>
<td style="text-align:center">PipedInputStream</td>
<td style="text-align:center">PipedOutputStream</td>
<td style="text-align:center">PipedReader</td>
<td style="text-align:center">PipedWriter</td>
</tr>
<tr>
<td style="text-align:left">缓存（Buffering）</td>
<td style="text-align:center">BufferedInputStream</td>
<td style="text-align:center">BufferedOutputStream</td>
<td style="text-align:center">BufferedReader</td>
<td style="text-align:center">BufferedWriter</td>
</tr>
<tr>
<td style="text-align:left">过滤（Filtering）</td>
<td style="text-align:center">FilterInputStream</td>
<td style="text-align:center">FilterOutputStream</td>
<td style="text-align:center">FilterReader</td>
<td style="text-align:center">FilterWriter</td>
</tr>
<tr>
<td style="text-align:left">解析（Parsing）</td>
<td style="text-align:center">PushbackInputStream StreamTokenizer</td>
<td style="text-align:center"></td>
<td style="text-align:center">PushbackReader LineNumberReader</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">字符串（Strings）</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">StringReader</td>
<td style="text-align:center">StringWriter</td>
</tr>
<tr>
<td style="text-align:left">数据（Data）</td>
<td style="text-align:center">DataInputStream</td>
<td style="text-align:center">DataOutputStream</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">格式化数据（Data-Formatted）</td>
<td style="text-align:center"></td>
<td style="text-align:center">PrintStream</td>
<td style="text-align:center"></td>
<td style="text-align:center">PrintWriter</td>
</tr>
<tr>
<td style="text-align:left">对象（Objects）</td>
<td style="text-align:center">ObjectInputStream</td>
<td style="text-align:center">ObjectOutputStream</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">工具（Utilities）</td>
<td style="text-align:center">SequenceInputStream</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="Java-5-以及之后版本"><a href="#Java-5-以及之后版本" class="headerlink" title="Java 5 以及之后版本"></a>Java 5 以及之后版本</h2><p>教程最开始是基于java5，但是最新的12,13版本也都类似。</p>
<h2 id="Java-IO-总览"><a href="#Java-IO-总览" class="headerlink" title="Java IO 总览"></a>Java IO 总览</h2><p>在本部分教程将给你Java io 的概述. 特别的，我将通过类和方法的目的给你分类。这个分类会帮助你正确的在将来选择使用对应的类和方法。</p>
<h3 id="输入和输出-源头和目标"><a href="#输入和输出-源头和目标" class="headerlink" title="输入和输出 - 源头和目标"></a>输入和输出 - 源头和目标</h3><p>“输入”以及“输出”这两个术语有时候容易引起歧义。一个应用的一部分输入可能是另一个的输出。一个输出流中写入的流，是一个输出流？还是一个来自你<br>读取的输出流中的流是输出流？毕竟一个输入流输出它从程序中读取到的数据，不是么？我个人觉得当刚接触学习Java IO的时候，这里是有一些困惑的。</p>
<p>出于尝试找到这个困惑的答案，我尝试给input和output赋予不同的名字来从概念上搞清楚，输入流从哪里来，输出流又输出到哪里。</p>
<p>Java中的IO 包几乎只关注从目标原始数据中读取和向目标写原始数据。最典型的源数据和目标数据如下：</p>
<pre><code>- 文件 Files
- 管道 Pipes
- 网络连接 Network Connections
- 内存缓存区（例如数组） In-memory Buffers (e.g. arrays)
- System.in, System.out, System.error
</code></pre><p>下图阐述了程序从数据源读取数据和向目标源写入数据的原理：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    Source--&gt;Program--&gt;Destination;</span><br></pre></td></tr></table></figure></p>
<h4 id="流（Streams）"><a href="#流（Streams）" class="headerlink" title="流（Streams）"></a>流（Streams）</h4><p>IO流是Java IO中的核心概念。流从概念上看是源源不断数据流。你可以从一个流中读取数据，或者写入数据到一个流中。流与数据来源、数据目标密切相关。<br>Java IO中的流可以基于字节Byte（读取或写入字节），也可以基于字符character（读取或写入字符）。</p>
<h4 id="输入流InputStream-输出流OutputStream-读入Reader-和-写出Writer"><a href="#输入流InputStream-输出流OutputStream-读入Reader-和-写出Writer" class="headerlink" title="输入流InputStream, 输出流OutputStream, 读入Reader 和 写出Writer"></a>输入流InputStream, 输出流OutputStream, 读入Reader 和 写出Writer</h4><p>需要从数据源读入数据的程序需要一个InputStream或者Reader。<br>需要向目标写入数据的程序需要一个OutputSteam或者Writer。如下所示：<br>Source –&gt; InputStream / Reader –&gt; Program<br>Program –&gt; OutputStream / Writer –&gt; Destination</p>
<p>InputStream\Reader与数据源关联.OutputStream\Writer与目标数据有关.</p>
<h3 id="Java-IO-的目的和特性"><a href="#Java-IO-的目的和特性" class="headerlink" title="Java IO 的目的和特性"></a>Java IO 的目的和特性</h3><p>Java IO 包包含许多InputStream, OutputStream, Reader , Writer类的子类.<br>设计如此多子类的原因是为了解决不同的问题，实现不同的目的。详情如下：</p>
<pre><code>- 访问文件 File Access
- 访问网络 Network Access
- 访问内存缓存 Internal Memory Buffer Access
- 线程间通信(管道) Inter-Thread Communication (Pipes)
- 缓存 Buffering
- 过滤器 Filtering
- 解析器 Parsing
- 读写文本 Reading and Writing Text (Readers / Writers)
- 读写基本数据类型 Reading and Writing Primitive Data (long, int etc.)
- 读写对象 Reading and Writing Objects
</code></pre><p>当你使用Java IO相关类去读写数据是，最好知道这些类的目的，这能让你更好的理解什么时候该用什么类解决问题。</p>
<h2 id="Java-IO-文件"><a href="#Java-IO-文件" class="headerlink" title="Java IO 文件"></a>Java IO 文件</h2><p>文件是java应用汇总常见的数据源和目标数据。这部分就带你搞java里的文件。这里不涉及技术细节，但是让你知道什么时候该用什么。单独分页里有详细说明。</p>
<h3 id="通过Java-IO读取文件"><a href="#通过Java-IO读取文件" class="headerlink" title="通过Java IO读取文件"></a>通过Java IO读取文件</h3><p>如果你需要从一个端读取文件到另一个端，你可以使用<a href="#FileInputStream">FileInputStream</a>或者<a href="#FileReader">FileReader</a>，<br>通过二进制形式读取用FileInputStream，通过文本化字符流读取用FileReader.这两个类让你一次一个字节或者一次一个字符的从文件的开始读取到文件结尾。<br>你不用读取整个文件，但是你只能按照文件数据的储存数据顺序读取。</p>
<p>如果你需要跳到文件某一部分，只读取文件某一部分或某几部分数据，可以使用<a href="#RandomAccessFile">RandomAccessFile</a>。</p>
<h3 id="通过Java-IO写入文件"><a href="#通过Java-IO写入文件" class="headerlink" title="通过Java IO写入文件"></a>通过Java IO写入文件</h3><p>通过二进制写入FileOutputStream，通过字符写入FileWriter。一次写一个字节或者一个字符，从文件开始到文件结尾。按照写入顺序存储。</p>
<p>如果你需要跳过某些文件，灵活的写入不同的地方,例如在文件最后写入，你可以用<a href="#RandomAccessFile">RandomAccessFile</a>.</p>
<h3 id="通过Java-IO随机访问文件"><a href="#通过Java-IO随机访问文件" class="headerlink" title="通过Java IO随机访问文件"></a>通过Java IO随机访问文件</h3><p>正如我上面提到的，你可通过RandomAccessFile类，随机访问文件。</p>
<p>随机访问并不意味着你真的可以从任意地方读取或写入数据.<br>他只是意味着你可以跳过文件，通过任何你想要的方式去同时读取或者写入数据。没有强制特定的访问顺序。这使得覆盖已经存在文件的某一部分，<br>文件尾写入，从中删除，当然也包括从任何你需要的地方进行读取成为可能。</p>
<h3 id="文件和目录信息访问"><a href="#文件和目录信息访问" class="headerlink" title="文件和目录信息访问"></a>文件和目录信息访问</h3><p>Sometimes you may need access to information about a file rather than its content.<br>For instance, if you need to know the file size or the file attributes of a file. The same may be true for a directory.<br>For instance, you may want to get a list of all files in a given directory.<br>Both file and directory information is available via the File class.<br>有时你可能需要访问文件的其他信息，而不是文件内容。例如你需要知道文件大小或者文件属性。对文件目录也一样，你可能需要知道某个目录下所有文件的列表。<br>文件信息和路径信息都可以通过<a href="#File">File</a>类获取到。</p>
<h2 id="Java-IO-管道-pipes"><a href="#Java-IO-管道-pipes" class="headerlink" title="Java IO 管道 pipes"></a>Java IO 管道 pipes</h2><pre><code>- 管道是java提供给同一个虚拟机上运行的两个线程通信的机制。所以管道可以是数据源也可以使目标数据。
- 不同jvm不同进程中的线程不能通过管道通信
- unix、linux中说的管道是运行在不同地址空间的进程通信手段
- 在java中，通过管道通信必须是运行在统一进程中的不同线程。
</code></pre><h3 id="通过Java-IO创建管道"><a href="#通过Java-IO创建管道" class="headerlink" title="通过Java IO创建管道"></a>通过Java IO创建管道</h3><pre><code>- PipedOutputStream
- PipedInputStream
- 一个线程的PipedOutputStream 和 另一个线程的PipedInputStream必须关联
- 构造方法关联
-  connect() 方法关联
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">import</span> java.io.IOException;</span><br><span class="line">    <span class="keyword">import</span> java.io.PipedInputStream;</span><br><span class="line">    <span class="keyword">import</span> java.io.PipedOutputStream;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PipeExample</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">final</span> PipedOutputStream output = <span class="keyword">new</span> PipedOutputStream();</span><br><span class="line">            <span class="keyword">final</span> PipedInputStream  input  = <span class="keyword">new</span> PipedInputStream(output);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">            Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        output.write(<span class="string">"Hello world, pipe!"</span>.getBytes());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">            Thread thread2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> data = input.read();</span><br><span class="line">                        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">                            System.out.print((<span class="keyword">char</span>) data);</span><br><span class="line">                            data = input.read();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    </span><br><span class="line">            thread1.start();</span><br><span class="line">            thread2.start();</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ``` </span><br><span class="line">### 管道和线程</span><br><span class="line">    - 当你使用两个关联的管道，传输一个线程的数据流到另一个数据流中时，另一个数据流又传输到再另外一个线程中时，read（）和write（）方法</span><br><span class="line">    在流中调用的时候是阻塞的，如果中间那个线程同时调用read和write方法，可能会造成死锁。</span><br><span class="line">    </span><br><span class="line">### 管道的备选方案</span><br><span class="line">    - 其实大多数情况下，线程间经常直接传输对象，而不是原始字节数据。</span><br><span class="line">    - todo：传对象则如何，在多线程专题中解释。</span><br><span class="line">    </span><br><span class="line">## Java IO 网络</span><br><span class="line"></span><br><span class="line">    - 网络知识这里不应该多BB</span><br><span class="line">    - 但是网络连接都是涉及到IO的操作，这几简单BB几句</span><br><span class="line">    - 一旦网络在两个进程之间建立，他们之间的数据传输就像文件传输一样。</span><br><span class="line">    - InputStream 读数据,  OutputStream 写数据</span><br><span class="line">    - 换句话说，通过java 网络api建立的的连接中，还是用java io来读写数据</span><br><span class="line">    - 你能写入文件，就能写入网络。需要改动的只有你写数据的组件是基于OutputStream实现的，而不是FileOutputStream。读入一个鸟样</span><br><span class="line">    ``` java</span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">                InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\myfile.txt"</span>);</span><br><span class="line">            </span><br><span class="line">                process(inputStream);</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">//do something with the InputStream</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="Java-IO-Byte-和-Char数组"><a href="#Java-IO-Byte-和-Char数组" class="headerlink" title="Java IO: Byte 和 Char数组"></a>Java IO: Byte 和 Char数组</h2><pre><code>- 在程序内部，字节和字符数组经常用来临时缓存数据，自然可以统统读进内存数组，然后通过下标访问。
但是如果你想从InputStream中Reader读取某一部分如何处理。
</code></pre><h3 id="通过InputStream或者Reader读取数组"><a href="#通过InputStream或者Reader读取数组" class="headerlink" title="通过InputStream或者Reader读取数组"></a>通过InputStream或者Reader读取数组</h3><pre><code>- 从数组中读取数据，要通过ByteArrayInputStream或者CharArrayReader包装的字节或者字符。这样array中的字节或字符数据就能被读取到了。
- CharArrayReader也一样，换个关键字
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//write data into byte array...</span></span><br><span class="line"></span><br><span class="line">InputStream input = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line"></span><br><span class="line"><span class="comment">//read first byte</span></span><br><span class="line"><span class="keyword">int</span> data = input.read();</span><br><span class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//do something with data</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//read next byte</span></span><br><span class="line">    data = input.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="通过OutputStream或者Writer写入数组"><a href="#通过OutputStream或者Writer写入数组" class="headerlink" title="通过OutputStream或者Writer写入数组"></a>通过OutputStream或者Writer写入数组</h3><pre><code>- ByteArrayOutputStream或者CharArrayWriter创建，往里面写入数据
- 写完了之后调用toByteArray()或者toCharArray()
- CharArrayWriter也一样
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ByteArrayOutputStream output = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">output.write(<span class="string">"This text is converted to bytes"</span>.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] bytes = output.toByteArray();</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="Java中的-System-in-System-out-和-System-error"><a href="#Java中的-System-in-System-out-和-System-error" class="headerlink" title="Java中的 System.in, System.out, 和 System.error"></a>Java中的 System.in, System.out, 和 System.error</h2><pre><code>- Java中三种经常用于提供输入输出的三种流
- System.out输出在控制台
- 这三个在虚拟机启动时由系统初始化，所以你不必初始化他们（尽管你可以在运行时交换他们）
</code></pre><h3 id="System-in"><a href="#System-in" class="headerlink" title="System.in"></a>System.in</h3><pre><code>- 是从控制台读入键盘输入数据的输入流
- 只能通过控制台或者终端读入与其相关的java程序
- 不常用，数据经常通过java 运行命令行参数，文件或者网络连接，或者GUI中的输入。
</code></pre><h3 id="System-out"><a href="#System-out" class="headerlink" title="System.out"></a>System.out</h3><pre><code>- 是一个通过字节写出到控制台或者终端的PrintStream
- debug用用啥的
</code></pre><h3 id="System-err"><a href="#System-err" class="headerlink" title="System.err"></a>System.err</h3><pre><code>- 和out一个狗样，只是文本区别
- 编译器可能给标个红字意思意思
</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\..."</span>);</span><br><span class="line">      System.out.println(<span class="string">"File opened..."</span>);</span><br><span class="line">    </span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">      System.err.println(<span class="string">"File opening failed:"</span>);</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    ``` </span><br><span class="line">    </span><br><span class="line">### 交换System流</span><br><span class="line">    - 虽然都是 java.lang.System类的静态成员，在jvm启动时就提前实例化了。但是他还是能手动更换。</span><br><span class="line">    ``` java</span><br><span class="line">    OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\data\\system.out.txt"</span>);</span><br><span class="line">    PrintStream printOut = <span class="keyword">new</span> PrintStream(output);</span><br><span class="line">    </span><br><span class="line">    System.setOut(printOut);</span><br></pre></td></tr></table></figure>

- 这样所写入System.out的数据都被重定向到system.out.txt文件中
- 记住，这样做你要保证在jvm关闭前，flush System.out流，并且关闭文件。以保证所有数据输入到文件中。
</code></pre><h2 id="Java-IO-流"><a href="#Java-IO-流" class="headerlink" title="Java IO: 流"></a>Java IO: 流</h2><pre><code>- java io流是你可以读取或者写入的数据流。通常和数据源目标数据相关，比如文件，网络连接等。
- 流中没有array的索引概念。在流中，你既不可以像在数组中前后移动游标，也不能像在文件操作中使用 RandomAccessFile去随意访问数据。
流就是一个连续的数据流。
- 一些流的实现允许你为了之后再次读取，向流中推入数据，比如PushbackInputStream。但是你推入的数据有限，而且你也不能像数组中那样，
随意遍历数据。数据只能被顺序读取。
- 基于字节的经常称作流stream，比如InputStream or OutputStream。这些流读取或者写入原始字符数据，
DataInputStream and DataOutputStream是例外，他们可能读写基础数据类型，比如int, long, float and double values.
- 基于字符的经常读入器和写出器&quot;Reader&quot; or &quot;Writer&quot;。
- 基于字符的流可以读入一个Latin1（ISO-8859-1）或者UNICODE编码下的一个字符。
</code></pre><h3 id="输入流InputStream"><a href="#输入流InputStream" class="headerlink" title="输入流InputStream"></a>输入流InputStream</h3><pre><code>- java.io.InputStream 是java io输入流的父类。如果你的组件要从流中读入数据，你要继承这个逼，而不是子类。这样能保证你的代码能接受
所有种类的输入流，而不是某一种具体的子类型。
- 也不是所有都能基于InputStream，如果你需要向流中回写数据，需要基于PushbackInputStream。
- 通常调用read()方法。翻译一个int类型的byte值，结束返回-1.
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input-file.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> data = input.read();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">  data = input.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="输出流OutputStream"><a href="#输出流OutputStream" class="headerlink" title="输出流OutputStream"></a>输出流OutputStream</h3><pre><code>- java.io.OutputStream是输出流的父类。
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\data\\output-file.txt"</span>);</span><br><span class="line">output.write(<span class="string">"Hello World"</span>.getBytes());</span><br><span class="line">output.close();</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="结合流Combining-Streams"><a href="#结合流Combining-Streams" class="headerlink" title="结合流Combining Streams"></a>结合流Combining Streams</h3><pre><code>- 你可以用缓存流BufferedInputStream包装输入流InputStream， BufferedOutputStream也一样。
- 你也可以用PushbackStream包装输入流。
- 或者合并两个输入流到一个 SequenceInputStream时序输入流
- 自定义类的的包装流

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                        <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input-file.txt"</span>));</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="Java-IO-输入解析"><a href="#Java-IO-输入解析" class="headerlink" title="Java IO: 输入解析"></a>Java IO: 输入解析</h2><pre><code>- String.replace()可以替换，但是每次替换都创建一个对象副本。 O(N * M)，N是String长度，M执行替换次数
</code></pre><h2 id="Java-IO-读入器和写出器Readers-and-Writers"><a href="#Java-IO-读入器和写出器Readers-and-Writers" class="headerlink" title="Java IO: 读入器和写出器Readers and Writers"></a>Java IO: 读入器和写出器Readers and Writers</h2><pre><code>- 和InputStream 、 OutputStream类似，只是基于字符单位
</code></pre><h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h3><pre><code>- 包含BufferedReader, PushbackReader, InputStreamReader, StringReader等子类
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Reader reader = <span class="keyword">new</span> FileReader(<span class="string">"c:\\data\\myfile.txt"</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> data = reader.read();</span><br><span class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">char</span> dataChar = (<span class="keyword">char</span>) data;</span><br><span class="line">    data = reader.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

- 这并不意味着并不代表每次read读入2个字节的char，这个看具体编码。
</code></pre><h3 id="结合InputStreams的Reader"><a href="#结合InputStreams的Reader" class="headerlink" title="结合InputStreams的Reader"></a>结合InputStreams的Reader</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">    Reader reader = <span class="keyword">new</span> InputStreamReader(inputStream);</span><br><span class="line">    ``` </span><br><span class="line">    </span><br><span class="line">### Writer</span><br><span class="line"></span><br><span class="line">    - 包括BufferedWriter 、 PrintWriter</span><br><span class="line">    ``` java</span><br><span class="line">        Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">"c:\\data\\file-output.txt"</span>);</span><br><span class="line">        </span><br><span class="line">        writer.write(<span class="string">"Hello World Writer"</span>);</span><br><span class="line">        writer.close();</span><br><span class="line">    ``` </span><br><span class="line">    </span><br><span class="line">### 结合Reader和Writers</span><br><span class="line">    ``` java</span><br><span class="line">    Reader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(...));</span><br><span class="line">    </span><br><span class="line">    Writer writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(...));</span><br><span class="line">    ``` </span><br><span class="line">## Java IO: 并发IO</span><br><span class="line">    - 如果你不能保证确定每个线程读取多少数据，或者按什么顺序去写出的话，就不应该有一个以上的线程同时从InputStream 或 Reader读取数据，</span><br><span class="line">    也不应该有一个以上的线程同时向OutputStream或 Writer写入数据</span><br><span class="line">    - 如果涉及到不同线程，处理不同数据顺序生命周期，要注意，线程间处理流的代码需要加<span class="keyword">synchronized</span></span><br><span class="line">    - 在  Java NIO中，你可以用一个线程通过多个channel渠道读入或者写出数据。例如，你有许多建立的网络连接，但是每个连接上只有少量数据</span><br><span class="line">    （聊天服务器），你可以用一个线程监控多个channel（连接）。</span><br><span class="line">    </span><br><span class="line">## Java IO: 异常处理</span><br><span class="line">    - Streams and Readers / Writers 用完通过调用后close()关闭。 </span><br><span class="line">    - <span class="keyword">finally</span>中关闭</span><br><span class="line">    - <span class="keyword">finally</span>中抛出错误怎么办？再<span class="keyword">try</span> <span class="keyword">catch</span></span><br><span class="line">    - close报错呢？异常处理模板。java7以后不用人为处理了？？？</span><br><span class="line">    </span><br><span class="line">## Java InputStream输入流</span><br><span class="line">    - 与数据源相关</span><br><span class="line">    ``` java</span><br><span class="line">        InputStream inputstream = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input-text.txt"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> data = inputstream.read();</span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">//do something with data...</span></span><br><span class="line">          doSomethingWithData(data);</span><br><span class="line">        </span><br><span class="line">          data = inputstream.read();</span><br><span class="line">        &#125;</span><br><span class="line">        inputstream.close();</span><br><span class="line">    ``` </span><br><span class="line">### 子类</span><br><span class="line">    - ByteArrayInputStream</span><br><span class="line">    - FileInputStream</span><br><span class="line">    - PipedInputStream</span><br><span class="line">    - BufferedInputStream</span><br><span class="line">    - FilterInputStream</span><br><span class="line">    - PushbackInputStream</span><br><span class="line">    - DataInputStream</span><br><span class="line">    - ObjectInputStream</span><br><span class="line">    - SequenceInputStream</span><br><span class="line"></span><br><span class="line">### read()方法</span><br><span class="line">    - InputStream的read()方法返回<span class="keyword">int</span>类型的<span class="keyword">byte</span>值。结尾返回-<span class="number">1</span>的<span class="keyword">int</span>类型</span><br><span class="line">    -  DataInputStream可以读基础类型</span><br><span class="line">    </span><br><span class="line">### read(byte[])方法     </span><br><span class="line">    - 读入<span class="keyword">byte</span>数组，返回真实读入的长度。</span><br><span class="line">    </span><br><span class="line">### 读入性能</span><br><span class="line">    - 读数组性能要比单独读入一个字节性能更好</span><br><span class="line">    - 好可能<span class="number">10</span>倍<span class="number">10</span>倍给你凉爽</span><br><span class="line">    - 读取速率决定于你定义的数组长度，操作系统或者硬件等。</span><br><span class="line">    - bugffer 尺寸<span class="number">8</span>kb会更大加速你的读取速率。</span><br><span class="line">    - 但是你的数组容量超过了底层操作或者硬件能力，你可能得不到一个效率提升。</span><br><span class="line">    </span><br><span class="line">### 通过BufferedInputStream的透明缓存</span><br><span class="line">    - Java BufferedInputStream一次读入大量的字符</span><br><span class="line">    - 也有较大速度提升</span><br><span class="line">    - 是InputStream子类，InputStream能用BufferedInputStream就能用</span><br><span class="line">    ``` java</span><br><span class="line">        InputStream input = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                              <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input-file.txt"</span>),</span><br><span class="line">                                <span class="number">1024</span> * <span class="number">1024</span>        <span class="comment">/* buffer size */</span></span><br><span class="line">            );</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="mark-and-reset-方法"><a href="#mark-and-reset-方法" class="headerlink" title="mark() and reset()方法"></a>mark() and reset()方法</h3><pre><code>- 子类不一定支持，如果支持的话，需要重写markSupported()返回true
- mark()方法标记当前已经读到数据的位置。可以用read方法从该处继续读取。reset方法再回到mark位置重新读取
</code></pre><h3 id="关闭输入流"><a href="#关闭输入流" class="headerlink" title="关闭输入流"></a>关闭输入流</h3><pre><code>- try-catch
</code></pre><h3 id="InputStream-转-Reader"><a href="#InputStream-转-Reader" class="headerlink" title="InputStream 转 Reader"></a>InputStream 转 Reader</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStream inputStream       = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input.txt"</span>);</span><br><span class="line">Reader      inputStreamReader = <span class="keyword">new</span> InputStreamReader(inputStream);</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="Java-OutputStream输出流"><a href="#Java-OutputStream输出流" class="headerlink" title="Java OutputStream输出流"></a>Java OutputStream输出流</h2><pre><code>- 输出流和目标数据相关
</code></pre><h3 id="write-byte-方法"><a href="#write-byte-方法" class="headerlink" title="write(byte)方法"></a>write(byte)方法</h3><pre><code>- 接受int型byte值
</code></pre><h2 id="Java-RandomAccessFile随机访问"><a href="#Java-RandomAccessFile随机访问" class="headerlink" title="Java RandomAccessFile随机访问"></a>Java RandomAccessFile随机访问</h2><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">"c:\\data\\file.txt"</span>, <span class="string">"rw"</span>);</span><br></pre></td></tr></table></figure>

- &quot;rw&quot;读写模式
</code></pre><h3 id="Access-Modes存取模式"><a href="#Access-Modes存取模式" class="headerlink" title="Access Modes存取模式"></a>Access Modes存取模式</h3><table>
<thead>
<tr>
<th style="text-align:center">Mode</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">r</td>
<td style="text-align:center">读. 调用写模式导致IO异常</td>
</tr>
<tr>
<td style="text-align:center">rw</td>
<td style="text-align:center">读写.</td>
</tr>
<tr>
<td style="text-align:center">rwd</td>
<td style="text-align:center">同步读写模式.所有文件更新同步写入磁盘</td>
</tr>
<tr>
<td style="text-align:center">rws</td>
<td style="text-align:center">同步读写模式.所有文件或者元数据更新同步写入磁盘 </td>
</tr>
</tbody>
</table>
<h3 id="在RandomAccessFile文件中查找"><a href="#在RandomAccessFile文件中查找" class="headerlink" title="在RandomAccessFile文件中查找"></a>在RandomAccessFile文件中查找</h3><p>在RandomAccessFile文件中进行读写操作，需要先定位文件指针在要读写的位置，也称作seek</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">"c:\\data\\file.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line"></span><br><span class="line">file.seek(<span class="number">200</span>);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="获取文件位置"><a href="#获取文件位置" class="headerlink" title="获取文件位置"></a>获取文件位置</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> position = file.getFilePointer();</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="读取字节"><a href="#读取字节" class="headerlink" title="读取字节"></a>读取字节</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">"c:\\data\\file.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> aByte = file.read();</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] dest      = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span>    offset    = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>    length    = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span>    bytesRead = randomAccessFile.read(dest, offset, length);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">"c:\\data\\file.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line"></span><br><span class="line">file.write(<span class="number">65</span>); <span class="comment">// ASCII code for A</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] bytes = <span class="string">"Hello World"</span>.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">file.write(bytes, <span class="number">2</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="Java-File"><a href="#Java-File" class="headerlink" title="Java File"></a>Java File</h3><p>Xy1018421411563</p>
<h2 id="Java-FileInputStream"><a href="#Java-FileInputStream" class="headerlink" title="Java FileInputStream"></a><a id="FileInputStream">Java FileInputStream</a></h2><p>Java文件输入类FileInputStream（java.io.FileInputStream），支持了从一个文件的字节流中读入内容的功能。FileInputStream是InputStream<br>的子类。这意味这你用FileInputStream用法类似InputStream。</p>
<h3 id="Java-FileInputStream-用法示例"><a href="#Java-FileInputStream-用法示例" class="headerlink" title="Java FileInputStream 用法示例"></a>Java FileInputStream 用法示例</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">        InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input-text.txt"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> data = input.read();</span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">//do something with data...</span></span><br><span class="line">          doSomethingWithData(data);</span><br><span class="line">        </span><br><span class="line">          data = input.read();</span><br><span class="line">        &#125;</span><br><span class="line">        input.close();</span><br><span class="line">    ``` </span><br><span class="line"></span><br><span class="line">提示：为了清晰起见，对应exception的处理这里省去了。想多了解自己滚去看异常去。</span><br><span class="line"></span><br><span class="line">### FileInputStream 构造函数</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span>. 参数是文件位置路径</span><br><span class="line">    ``` java</span><br><span class="line">        String path = <span class="string">"C:\\user\\data\\thefile.txt"</span>;</span><br><span class="line">        </span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(path);</span><br></pre></td></tr></table></figure>

两个<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unix系统下类似这样</span><br><span class="line">    ``` java</span><br><span class="line">        String path = &quot;/home/jakobjenkov/data/thefile.txt&quot;;</span><br></pre></td></tr></table></figure>

2. 参数是文件对象
    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String path = <span class="string">"C:\\user\\data\\thefile.txt"</span>;</span><br><span class="line">File   file = <span class="keyword">new</span> File(path);</span><br><span class="line"></span><br><span class="line">FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(file);</span><br></pre></td></tr></table></figure>

3. shit
</code></pre><h3 id="read-方法"><a href="#read-方法" class="headerlink" title="read()方法"></a>read()方法</h3><pre><code>- 返回包含byte值的int对象
- 如果返回-1就表示流中再读不到数据了，可以close了
- 是读到-1的int类型，不是byte类型
- 用法同InputStream中的read()方法.
    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fileInputStream =</span><br><span class="line">    <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input-text.txt"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> data = fileInputStream.read();</span><br><span class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// do something with data variable</span></span><br><span class="line"></span><br><span class="line">    data = fileInputStream.read(); <span class="comment">// read next byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    while结束循环时，从流中读出所有数据。
</code></pre><h3 id="read-byte-方法"><a href="#read-byte-方法" class="headerlink" title="read(byte[])方法"></a>read(byte[])方法</h3><pre><code>- 读入byte数组
- 继承自 Java InputStream 类
- int read(byte[]) 从流中读取字节直到数组塞满，然后当做参数传入
- int read(byte[], int offset, int length)从流中读取lengh长度字节，从offset下标开始，放入数组中
- 返回读入数组的byte数量。如果读入数据的长度小于数组容量，则就读入剩余数据后返回数组长度。
- 全读入后返回-1
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input-text.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] data      = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span>    bytesRead = fileInputStream.read(data, <span class="number">0</span>, data.length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line">  doSomethingWithData(data, bytesRead);</span><br><span class="line"></span><br><span class="line">  bytesRead = fileInputStream.read(data, <span class="number">0</span>, data.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

- read(data, 0, data.length) 等同于 read(data) .
</code></pre><h3 id="读入性能"><a href="#读入性能" class="headerlink" title="读入性能"></a>读入性能</h3><pre><code>- 读数组性能要比单独读入一个字节性能更好
- 好可能10倍10倍给你凉爽
- 读取速率决定于你定义的数组长度，操作系统或者硬件等。
- bugffer 尺寸8kb会更大加速你的读取速率。
- 但是你的数组容量超过了底层操作或者硬件能力，你可能得不到一个效率提升。
</code></pre><h3 id="通过BufferedInputStream的透明缓存"><a href="#通过BufferedInputStream的透明缓存" class="headerlink" title="通过BufferedInputStream的透明缓存"></a>通过BufferedInputStream的透明缓存</h3><pre><code>- Java BufferedInputStream一次读入大量的字符
- 也有较大速度提升
- 是InputStream子类，InputStream能用BufferedInputStream就能用
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                      <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input-file.txt"</span>),</span><br><span class="line">                        <span class="number">1024</span> * <span class="number">1024</span>        <span class="comment">/* buffer size */</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="关闭文件输入流"><a href="#关闭文件输入流" class="headerlink" title="关闭文件输入流"></a>关闭文件输入流</h3><pre><code>- 读完了必须关
- 调用InputStream中的close()方法 
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input-text.txt"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> data = fileInputStream.read();</span><br><span class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>) &#123;</span><br><span class="line">  data = fileInputStream.read();</span><br><span class="line">&#125;</span><br><span class="line">fileInputStream.close();</span><br></pre></td></tr></table></figure>

- 不是100%鲁棒的，如果中间出现读取异常，永远不close
- 所以finally
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>( FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"file.txt"</span>) ) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> data = fileInputStream.read();</span><br><span class="line">    <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">        data = fileInputStream.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><h3 id="FileInputStream-转-Reader"><a href="#FileInputStream-转-Reader" class="headerlink" title="FileInputStream 转 Reader"></a>FileInputStream 转 Reader</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStream inputStream       = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input.txt"</span>);</span><br><span class="line">Reader      inputStreamReader = <span class="keyword">new</span> InputStreamReader(inputStream);</span><br></pre></td></tr></table></figure>
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/20/java-io你总得搞清楚吧/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Howard">
      <meta itemprop="description" content="午夜向日葵，晌午夜光杯。跛者脚下路，屠夫腕上佛。">
      <meta itemprop="image" content="/images/avatar/P1070776.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="华氏温度">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/20/java-io你总得搞清楚吧/" itemprop="url">
                  java io你总得搞清楚吧
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2020-02-20 23:13:10" itemprop="dateCreated datePublished" datetime="2020-02-20T23:13:10+08:00">2020-02-20</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/码文/" itemprop="url" rel="index"><span itemprop="name">码文</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/20/java-io你总得搞清楚吧/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/02/20/java-io你总得搞清楚吧/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="java-io-包-BIO"><a href="#java-io-包-BIO" class="headerlink" title="java.io 包 BIO"></a>java.io 包 BIO</h3><pre><code>- 基于流模型实现
- File 抽象、输入输出流
- 交互方式是同步、阻塞的方式
- 调用是可靠的线性顺序
- 简单、直观
- IO 效率和扩展性存在局限性，容易成为应用性能的瓶颈。
- java.net 下面部分网络 API:Socket、ServerSocket、HttpURLConnection,同步阻塞 IO 类库.网络通信同样是 IO 行为
- IO 不仅仅是对文件的操作，网络编程中，比如 Socket 通信，都是典型的 IO 操作目标。
- 输入流、输出流（InputStream/OutputStream）是用于读取或写入字节的，例如操作图片文件。
- 而 Reader/Writer 则是用于操作字符，增加了字符编解码等功能，适用于类似从文件中读取或者写入文本信息。
本质上计算机操作的都是字节，不管是网络通信还是文件读取，Reader/Writer 相当于构建了应用逻辑和原始数据之间的桥梁。
- BufferedOutputStream 等带缓冲区的实现，可以避免频繁的磁盘读写，进而提高 IO 处理效率。这种设计利用了缓冲区，
将批量数据进行一次操作，但在使用中千万别忘了 flush。
- 很多 IO 工具类都实现了 Closeable 接口，因为需要进行资源的释放。比如，打开 FileInputStream，它就会获取相应的文件描述符
（FileDescriptor），需要利用 try-with-resources、 try-finally 等机制保证 FileInputStream 被明确关闭，
进而相应文件描述符也会失效，否则将导致资源无法被释放。
</code></pre><h3 id="java-nio-包-NIO"><a href="#java-nio-包-NIO" class="headerlink" title="java.nio 包 NIO"></a>java.nio 包 NIO</h3><pre><code>- Channel、Selector、Buffery1018 等新的抽象
- 多路复用的、同步非阻塞
- 高性能数据操作
</code></pre><h3 id="NIO-2"><a href="#NIO-2" class="headerlink" title="NIO 2"></a>NIO 2</h3><pre><code>- 异步非阻塞 IO 方式
- 异步 IO 操作基于事件和回调机制，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/12/翻译-Spring-AOP-使用-CGLib-还是JDK动态代理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Howard">
      <meta itemprop="description" content="午夜向日葵，晌午夜光杯。跛者脚下路，屠夫腕上佛。">
      <meta itemprop="image" content="/images/avatar/P1070776.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="华氏温度">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/12/翻译-Spring-AOP-使用-CGLib-还是JDK动态代理/" itemprop="url">
                  [翻译]Spring AOP 使用 CGLib 还是JDK动态代理
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2020-02-12 22:34:44" itemprop="dateCreated datePublished" datetime="2020-02-12T22:34:44+08:00">2020-02-12</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/12/翻译-Spring-AOP-使用-CGLib-还是JDK动态代理/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/02/12/翻译-Spring-AOP-使用-CGLib-还是JDK动态代理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote><p>原文链接：<a href="http://cliffmeyers.com/blog/2006/12/29/spring-aop-cglib-or-jdk-dynamic-proxies.html" target="_blank" rel="noopener">http://cliffmeyers.com/blog/2006/12/29/spring-aop-cglib-or-jdk-dynamic-proxies.html</a></p>
</blockquote>
<p>即使你不是面向切面编程的拥趸,但是如果你用到了spring 框架中事务管理的功能,那就意味着你用到了面向切面编程中的动态AOP代理,尽管你并没有主动的显式<br>使用它.Spring框架可以用CGLIB和JDK动态代理,两个不同的技术手段在运行时创建动态代理.  </p>
<p>如果目标类实现了一个或多个接口,那么Spring将创建一个实现了这个类每个接口的JDK动态代理类.如果目标类没有实现任何一个接口,<br>Spring将使用CGlib创建一个”继承”目标类的新子类.这个不同的实现方式导致了一个重要的区别,一个JDK动态代理类不能(强)转化为原始目标类,因为它只是<br>一个碰巧和目标类实现了相同接口的类.若果你在你的程序中使用到了JDK的动态代理特性,也间接推动了你面向接口编程,因为通常是通过这些接口去调用代理类.</p>
<p>另一种方式,如果你的程序里完全没用到接口,spring将创建一个大致能被当成目标类本身使用的Cglib代理类.</p>
<p>当然也有一种不论在什么情况下强制创建Cglib代理的方法.<a href="https://docs.spring.io/spring/docs/2.0.0/reference/aop.html#d0e9015" target="_blank" rel="noopener">详情见此.</a></p>
<p>如果你在使用spring管理你的服务层的时候,报出了奇怪的类型转换错误,希望这篇文章能给你启发.</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/10/java-中的动态代理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Howard">
      <meta itemprop="description" content="午夜向日葵，晌午夜光杯。跛者脚下路，屠夫腕上佛。">
      <meta itemprop="image" content="/images/avatar/P1070776.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="华氏温度">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/10/java-中的动态代理/" itemprop="url">
                  java 中的动态代理
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2020-02-10 21:21:47" itemprop="dateCreated datePublished" datetime="2020-02-10T21:21:47+08:00">2020-02-10</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/码文/" itemprop="url" rel="index"><span itemprop="name">码文</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/10/java-中的动态代理/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/02/10/java-中的动态代理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>动态类型语言 静态类型语言: 语言类型信息在运行时检查,还是编译期检查</li>
<li>强类型语言 弱类型语言: 不同类型变量赋值时,是否需要显示的进行类型转换</li>
<li>反射机制是 Java 语言提供的一种基础功能，赋予程序在运行时自省（introspect，官方用语）的能力。通过反射我们可以直接操作类或者对象，<br>比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。</li>
<li>动态代理是一个代理机制。代理可以看作是对调用目标的一个包装，对目标代码的调用不是直接发生的，而是通过代理完成。<br>其实很多动态代理场景，我认为也可以看作是装饰器（Decorator）模式的应用.</li>
<li>代理可以让调用者与实现者之间解耦.比如进行 RPC 调用，框架内部的寻址、序列化、反序列化等，对于调用者往往是没有太大意义的，通过代理，<br>可以提供更加友善的界面。</li>
<li>JDK Proxy 的优势：<ol>
<li>最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 cglib 更加可靠。</li>
<li>平滑进行 JDK 版本升级，而字节码类库通常需要进行更新以保证在新版 Java 上能够使用。</li>
<li>代码实现简单。</li>
</ol>
</li>
<li>基于类似 cglib 框架的优势：<ol>
<li>有的时候调用目标可能不便实现额外接口，从某种角度看，限定调用者实现接口是有些侵入性的实践，类似 cglib 动态代理就没有这种限制。</li>
<li>只操作我们关心的类，而不必为其他相关类增加工作量。</li>
<li>高性能。</li>
</ol>
</li>
<li>静态代理：事先写好代理类，可以手工编写，也可以用工具生成。缺点是每个业务类都要对应一个代理类，非常不灵活。</li>
<li>动态代理：运行时自动生成代理对象。缺点是生成代理代理对象和调用代理方法都要额外花费时间。</li>
<li>JDK动态代理：基于Java反射机制实现，必须要实现了接口的业务类才能用这种办法生成代理对象。新版本也开始结合ASM机制。</li>
<li>cglib动态代理：基于ASM机制实现，通过生成业务类的子类作为代理类。  </li>
</ol>
<h4 id="项目实操"><a href="#项目实操" class="headerlink" title="项目实操"></a>项目实操</h4><ol>
<li>项目背景: 由于家技术架构改革,强行接入基于grpc的服务.在build请求请求和解析结果的时候十分繁琐,为了快速排查问题,使用动态代理打印请求和结果.</li>
<li><p>心路历程:</p>
<ol>
<li>所有的资料和文档都说通过jdk的实现的动态代理是基于接口的.然后就也假模假式的定义了个接口.</li>
<li><p>可是为啥必须定义接口?</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDynamicProxy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloImpl hello = <span class="keyword">new</span> HelloImpl();</span><br><span class="line">        MyInvocationHandler handler = <span class="keyword">new</span> MyInvocationHandler(hello);</span><br><span class="line">        <span class="comment">// 构造代码实例</span></span><br><span class="line">        Hello proxyHello = (Hello) Proxy.newProxyInstance(HelloImpl.class.getClassLoader(), HelloImpl.class.getInterfaces(), handler);</span><br><span class="line">        <span class="comment">// 调用代理方法</span></span><br><span class="line">        proxyHello.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">implements</span>  <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Invoking sayHello"</span>);</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是本身的代码,为啥我非得实现那个该死的hello接口?(翻译腔)?? 删除试试,运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java.lang.ClassCastException: com.sun.proxy.<span class="variable">$Proxy0</span> cannot be cast to proxy.Hello</span><br><span class="line">	at proxy.MyDynamicProxy.main(MyDynamicProxy.java:10)</span><br></pre></td></tr></table></figure>
<p>强转出问题了,代理类0不能强转成Hello类,为何?咱们冷静分析下.<br>这还用冷静分析?太智障了,hello和helloImpl在删除了implement hello 之后,根本没关系,你强转Hello那是必定要爆炸的,因为你传入newProxyInstance<br>方法中的参数,都是helloImpl的相关类信息.<strong>Proxy.newProxyInstance(HelloImpl.class.getClassLoader(), HelloImpl.class.getInterfaces(), handler);</strong><br>继续冷静分析,那就是说通过实现了Hello接口,所以我传HelloImpl给newProxyInstance方法,这个方法一定通过<strong>HelloImpl.class.getInterfaces()</strong><br>找到了实现的接口类Hello,之后根据被代理的接口来动态生成代理类的class文件，动态生成的代理类已经继承了Proxy类的，就不能再继承其他的类，<br>所以只能靠实现被代理类的接口的形式，故JDK的动态代理必须有接口。超类代理目标类.</p>
</li>
<li>spring boot中使用<br>MyInvocationHandler 可以让框架帮你创建而已.</li>
</ol>
</li>
<li>总结:<ul>
<li>本质:超类代理目标类.或者目标类的新实例,本身</li>
<li>需要和想要代理的类建立联系</li>
<li>java单继承,所以只能实现接口</li>
<li>invoke方法中利用jdk反射的方式去调用真正的被代理类的业务方法,需要反射获得代理类的有关参数，必须要通过某个类，反射获取有关方法</li>
<li>成功返回的是object类型，要获取原类，只能继承/实现，或者就是那个代理类.</li>
</ul>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/06/spring-boot-starter帮我们做了什么/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Howard">
      <meta itemprop="description" content="午夜向日葵，晌午夜光杯。跛者脚下路，屠夫腕上佛。">
      <meta itemprop="image" content="/images/avatar/P1070776.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="华氏温度">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/06/spring-boot-starter帮我们做了什么/" itemprop="url">
                  spring boot starter帮我们做了什么
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2020-02-06 21:58:26" itemprop="dateCreated datePublished" datetime="2020-02-06T21:58:26+08:00">2020-02-06</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/码文/" itemprop="url" rel="index"><span itemprop="name">码文</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/06/spring-boot-starter帮我们做了什么/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/02/06/spring-boot-starter帮我们做了什么/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Maven-tree-分析"><a href="#Maven-tree-分析" class="headerlink" title="Maven tree 分析"></a>Maven tree 分析</h4><pre><code>- spring-boot-starter
    - jakarta.annotation-api(提供了一系列声明式编程通用的注解)
    - snakeyaml(yaml文件解析工具)
    - spring-boot
        - spring-context(提供一个运行时的环境，用以保存各个对象的状态。)
            - spring-aop
                - spring-beans(Bean 的定义、Bean 的创建以及对 Bean 的解析)
                - spring-core(定义了资源的访问方式)
            - spring-beans
                - spring-core
            - spring-core
            - spring-expression(Spring Expression Language)
                - spring-core
        - spring-core
    - spring-boot-autoconfigure(自动配置)
        - spring-boot
    - spring-boot-starter-logging(日志模块)
        - jul-to-slf4j
        - log4j-to-slf4j
        - logback-classic
    - spring-core
        - spring-jcl(日志)
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/04/http协议要点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Howard">
      <meta itemprop="description" content="午夜向日葵，晌午夜光杯。跛者脚下路，屠夫腕上佛。">
      <meta itemprop="image" content="/images/avatar/P1070776.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="华氏温度">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/04/http协议要点/" itemprop="url">
                  http协议要点
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2020-02-04 14:17:55" itemprop="dateCreated datePublished" datetime="2020-02-04T14:17:55+08:00">2020-02-04</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/码文/" itemprop="url" rel="index"><span itemprop="name">码文</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/04/http协议要点/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/02/04/http协议要点/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h4><ol>
<li>一说是协议群的统称,互联网协议.</li>
<li>分层:应用层 传输层 网络层 数据链路层.分层的意义:接口和实现分离有相同的意义,有搞懂改本层实现就好了</li>
<li>应用层:提供应用服务的通信活动.http ftp DNS服务</li>
<li>传输层:对应用层提供处于网络连接中的两台计算机之间的数据传输.TCP(transmission control protocol)  UDP(user data protocol)</li>
<li>网络层:处理网络上流动的数据包.数据包是网络传输的最小单位.规定了通过怎样的路径到达对方计算机,并把数据包传递给对方. ip</li>
<li>数据链路层:连接网络的硬件部分.操作系统,网卡,光纤.</li>
<li>IP(internet protocol):区别ip地址.<br>网络层.保证把各种数据包传送到对方哪里,其中依靠ip地址(指明节点被分配到的地址)和mac地址(网卡所属的固定地址).<br>经过多台网络设备中转的时候,通过ARP协议通过通信ip地址可以反查出对应的MAC地址.</li>
<li>TCP:位于传输层,提供可靠的字节流服务.字节流:将大块数据分割成数据段(segment)为单位的数据包进行管理.可靠传输:通过三次握手能确认是不是传输接受罚金给对方了.</li>
<li>三次握手: 发送端发送一个带有<strong>SYN</strong>标志的数据包给接收方;接收方收到后,回传一个<strong>SYN/ACK</strong>标志,表示确认信息;发送端再回传一个<strong>ACK</strong>标志,代表握手结束.</li>
<li>DNS:域名解析服务</li>
<li>URI和URL:统一资源标识符&amp;统一资源定位符  </li>
</ol>
<h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><ol>
<li>概念:<ul>
<li>HyperText Transfer Protocol 超文本传输协议  </li>
<li>超文本:html css js 图片 音视频 文件  </li>
<li>s端和c端通信协议,c端发起请求,s端返回响应</li>
</ul>
</li>
<li>特点:<ul>
<li>支持c/s模式</li>
<li>简单快速</li>
<li>灵活</li>
<li>无连接:每次连接只处理一个请求,收到响应后断开连接,尽快将资源释放.但是之后随着访问次数变多,每次请求都建立,断开tcp连接,效率很低.<br><strong>Keep-Alive</strong>解决了这个问题,保持持续连接.可以后续继续使用,但是也占用着资源.这里注意keepalive时间和意外断开等.</li>
<li>无状态:没有记忆能力,不处理事务,每个请求相互独立.可能每次请求传输大量重复内容.<br><strong>Cookie</strong>客户端保存了一些信息和状态.关闭浏览器和清除就消失.<strong>session</strong>服务端保存的信息和状态,服务端设置过期时间等.</li>
<li>管线化:可以同时请求.可以同时发出多个请求,不用等待响应返回.幂等的请求才会被管道化GET HEAD 而POST不会</li>
</ul>
</li>
<li>http消息结构<ul>
<li>请求消息:请求行 + 请求头字段 + 一个空行 + 消息主体</li>
</ul>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/13/java-HashMap-全解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Howard">
      <meta itemprop="description" content="午夜向日葵，晌午夜光杯。跛者脚下路，屠夫腕上佛。">
      <meta itemprop="image" content="/images/avatar/P1070776.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="华氏温度">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/13/java-HashMap-全解析/" itemprop="url">
                  java HashMap 全解析
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2019-12-13 15:16:26" itemprop="dateCreated datePublished" datetime="2019-12-13T15:16:26+08:00">2019-12-13</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/码文/" itemprop="url" rel="index"><span itemprop="name">码文</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/13/java-HashMap-全解析/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/13/java-HashMap-全解析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="我们分析的HashMap主要以分析java8实现为主"><a href="#我们分析的HashMap主要以分析java8实现为主" class="headerlink" title="我们分析的HashMap主要以分析java8实现为主"></a>我们分析的HashMap主要以分析java8实现为主</h3><h3 id="HashMap概述摘要"><a href="#HashMap概述摘要" class="headerlink" title="HashMap概述摘要"></a>HashMap概述摘要</h3><ul>
<li>继承AbstractMap父类</li>
<li>实现Map&lt;K, V&gt;, Cloneable, Serializable接口</li>
<li>数组（Node[] table）和链表结合组成的复合结构</li>
<li>数组被分为一个个桶（bucket），通过哈希值决定了键值对在这个数组的寻址；</li>
<li>哈希值相同的键值对，则以链表形式存储，如果链表大小超过阈值（TREEIFY_THRESHOLD, 8），链表就会被改造为树形结构。</li>
<li>HashMap 的性能表现非常依赖于哈希码的有效性</li>
</ul>
<h3 id="对比Hashtable、HashMap、LinkedHashMap、TreeMap"><a href="#对比Hashtable、HashMap、LinkedHashMap、TreeMap" class="headerlink" title="对比Hashtable、HashMap、LinkedHashMap、TreeMap"></a>对比Hashtable、HashMap、LinkedHashMap、TreeMap</h3><ol>
<li>Hashtable<ul>
<li>早期 Java 类库</li>
<li>同步的(额外的性能开销)</li>
<li>不支持 null 键和值</li>
</ul>
</li>
<li>HashMap<ul>
<li>不同步</li>
<li>支持 null 键和值</li>
<li>通常put 或者 get 操作，可以达到常数时间的性能</li>
</ul>
</li>
<li>LinkedHashMap<ul>
<li>遍历顺序符合插入顺序</li>
<li>维护一个双向链表</li>
<li>通过特定构造函数,创建反映访问顺序的实例,类似于实现removeEldestEntry</li>
</ul>
</li>
<li>TreeMap<ul>
<li>基于红黑树</li>
<li>提供顺序访问,由键的顺序关系决定</li>
<li>get、put、remove 之类操作是 O（log(n)）的时间复杂度</li>
<li>具体顺序可以由指定的 Comparator,或根据键的自然顺序<h3 id="HashMap的内部数据结构"><a href="#HashMap的内部数据结构" class="headerlink" title="HashMap的内部数据结构"></a>HashMap的内部数据结构</h3></li>
</ul>
</li>
<li>默认初始大小16<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 16;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>容量和负载系数决定了可用的桶的数量</li>
<li>空桶太多会浪费空间，如果使用的太满则会严重影响操作的性能.只有一个桶，那么它就退化成了链表，完全不能提供所谓常数时间存的性能。</li>
<li>负载因子 * 容量 &gt; 元素数量,同时它是 2 的幂数.所以并不是简单的上一个list.size!!!</li>
</ul>
<ol start="2">
<li><p>最大容量2^30次方</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final int MAXIMUM_CAPACITY = 1073741824;</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认负载因子0.75</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final <span class="built_in">float</span> DEFAULT_LOAD_FACTOR = 0.75F;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>建议不要设置超过 0.75 的数值，因为会显著增加冲突，降低 HashMap 的性能。</li>
<li>如果使用太小的负载因子，按照上面的公式，预设容量值也进行调整，否则可能会导致更加频繁的扩容，增加无谓的开销，本身访问性能也会受影响。</li>
</ul>
<ol start="4">
<li>树化临界值8<br>执行put操作的时候，会出现桶碰撞的情况，这时候桶索引值相同的键值对会以一个链表的形式存在于hash桶中，但是当链表长度很长的时候，<br>查找的性能会很低.当链表的长度超过TREEIFY_THRESHOLD（8）的时候，链表会树化，即通过treeifyBin()方法转换成红黑树。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final int TREEIFY_THRESHOLD = 8;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>树化改造，对应逻辑主要在 putVal 和 treeifyBin 中。</li>
<li>为什么 HashMap 要树化呢？本质上这是个安全问题。因为在元素放置过程中，如果一个对象哈希冲突，都被放置到同一个桶里，则会形成一个链表，<br>我们知道链表查询是线性的，会严重影响存取的性能。</li>
</ul>
<ol start="5">
<li><p>去树化临界值6<br>节点数小于6的时候，从树结构变回链表</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final int UNTREEIFY_THRESHOLD = 6;</span><br></pre></td></tr></table></figure>
</li>
<li><p>去树化临界值6<br>节点数小于6的时候，从树结构变回链表</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final int MIN_TREEIFY_CAPACITY = 64;</span><br></pre></td></tr></table></figure>
</li>
<li><p>resize 方法兼顾两个职责，创建初始存储表格，或者在容量不满足需求的时候，进行扩容（resize）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Node[] tab; Node p; <span class="keyword">int</span> , i; </span><br><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) = <span class="number">0</span>)</span><br><span class="line"> n = (tab = resize()).length;</span><br><span class="line"> <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == ull)</span><br><span class="line"> tab[i] = newNode(hash, key, value, nll); </span><br><span class="line"><span class="keyword">else</span> &#123; /</span><br><span class="line">/ ... </span><br><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line"> <span class="comment">// -1 for first </span></span><br><span class="line">treeifyBin(tab, hash); </span><br><span class="line"><span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>门限值等于（负载因子）x（容量），如果构建 HashMap 的时候没有指定它们，那么就是依据相应的默认常量值。</li>
<li>门限通常是以倍数进行调整 （newThr = oldThr &lt;&lt; 1），我前面提到，根据 putVal 中的逻辑，当元素个数超过门限大小时，则调整 Map 大小。</li>
<li>扩容后，需要将老的数组中的元素重新放置到新的数组，这是扩容的一个主要开销来源。</li>
</ul>
<ol start="8">
<li><p>在放置新的键值对的过程中，如果发生下面条件，就会发生扩容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (++size &gt; threshold) resize();</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体键值对在哈希表中的位置（数组 index）取决于下面的位运算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>不是 key 本身的 hashCode，而是来自于 HashMap 内部的另外一个 hash 方法.<br>高位数据移位到低位进行异或运算呢?这是因为有些数据计算出的哈希值差异主要在高位，而 HashMap 里的哈希寻址是忽略容量以上的高位的，<br>那么这种处理就可以有效避免类似情况下的哈希碰撞。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> h; </span><br><span class="line"><span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt;<span class="number">16</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><ol>
<li>Hashtable和synchronizedMap对比<ul>
<li>Hashtable 等同步容器,Collections.synchronizedMap同步包装器（Synchronized Wrapper）都是粗粒度的同步方式，在高并发情况下，<br>性能比较低下</li>
<li>Hashtable 本身低效,这是将 put、get、size 等各种方法加上“synchronized”,导致了所有并发操作都要竞争同一把锁.<br>一个线程在进行同步操作时，其他线程只能等待，大大降低了并发操作的效率。</li>
<li>SynchronizedMap同步包装器,操作虽然不再声明成为 synchronized,但是同步对象是synchronized (mutex) {return m.size();}.没有真正意义上的改进</li>
<li></li>
</ul>
</li>
<li>ConcurrentHashMap 分析<ol>
<li>早期 ConcurrentHashMap<ul>
<li>分离锁:将内部进行分段（Segment），里面则是 HashEntry 的数组，和 HashMap 类似，哈希相同的条目也是以链表形式存放。</li>
<li>HashEntry 内部使用 volatile 的 value 字段来保证可见性，也利用了不可变对象的机制以改进利用 Unsafe 提供的底层能力，<br>比如 volatile access，去直接完成部分操作，以最优化性能，毕竟 Unsafe 中的很多操作都是 JVM intrinsic 优化过的。</li>
<li>在进行并发操作的时候，只需要锁定相应段，这样就有效避免了类似 Hashtable 整体同步的问题，大大提高了性能。</li>
<li>Segment 的数量由所谓的 concurrentcyLevel 决定，默认是 16,也可以在相应构造函数直接指定.必须是2 的幂数值</li>
<li></li>
<li><img src="/2019/12/13/java-HashMap-全解析/1.png" alt="早期 ConcurrentHashMap">  </li>
<li>get操作,需要保证的是可见性，所以并没有什么同步逻辑。</li>
<li>put 操作，首先是通过二次哈希避免哈希冲突，然后以 Unsafe 调用方式，直接获取相应的 Segment，然后进行线程安全的 put 操作.<br>ConcurrentHashMap 会获取再入锁保证数据一致性,Segment 本身就是基于 ReentrantLock 的扩展实现，所以，在并发修改期间，相应 Segment 是被锁定的。<br>重复性的扫描，以确定相应 key 值是否已经在数组里面，进而决定是更新还是放置操作.resize会单独对 Segment 进行扩容.</li>
<li>size 方法:如果不进行同步，简单的计算所有 Segment 的总值，可能会因为并发 put，导致结果不准确但是直接锁定所有 Segment 进行计算，就会变得非常昂贵。<br>分离锁也限制了 Map 的初始化等操作。分段计算两次，两次结果相同则返回，否则对所以段加锁重新计算.</li>
<li>ConcurrentHashMap 的实现是通过重试机制（RETRIES_BEFORE_LOCK，指定重试次数 2），来试图获得可靠值。<br>如果没有监控到发生变化（通过对比 Segment.modCount），就直接返回，否则获取锁进内部仍然有 Segment 定义行操作。<br>-1.7 put加锁 通过分段加锁segment，一个hashmap里有若干个segment，每个segment里有若干个桶，桶里存放K-V形式的链表，<br>put数据时通过key哈希得到该元素要添加到的segment，然后对segment进行加锁，然后再哈希，计算得到给元素要添加到的桶，<br>然后遍历桶中的链表，替换或新增节点到桶中</li>
<li>size 分段计算两次，两次结果相同则返回，否则对所以段加锁重新计算</li>
</ul>
</li>
<li>Java 8 和之后ConcurrentHashMap<ul>
<li>HashMap 结构非常相似.大的桶（bucket）数组，然后内部也是一个个所谓的链表结构（bin），同步的粒度要更细致一些。</li>
<li>内部仍然有 Segment 定义,仅仅是为了保证序列化时的兼容性而已，不再有任何结构上的用处。segment数量与桶数量一致；</li>
<li>修改为 lazy-load 形式，这样可以有效避免初始开销</li>
<li>volatile 来保证可见性。</li>
<li>CAS 等操作，在特定场景进行无锁并发操作。</li>
<li>Unsafe、LongAdder 之类底层手段，进行极端情况的优化。</li>
<li>Key 是 final 的，因为在生命周期中，一个条目的 Key 发生变化是不可能的；与此同时 val，则声明为 volatile，以保证可见性。</li>
<li>1.8 put CAS 加锁 1.8中不依赖与segment加锁，segment数量与桶数量一致；<br>首先判断容器是否为空，为空则进行初始化利用volatile的sizeCtl作为互斥手段，如果发现竞争性的初始化，就暂停在那里，等待条件恢复，<br>否则利用CAS设置排他标志（U.compareAndSwapInt(this, SIZECTL, sc, -1)）;否则重试</li>
<li>对key hash计算得到该key存放的桶位置，判断该桶是否为空，为空则利用CAS设置新节点<br>否则使用synchronize加锁，遍历桶中数据，替换或新增加点到桶中<br>最后判断是否需要转为红黑树，转换之前判断是否需要扩容.</li>
<li>size 利用LongAdd累加计算</li>
</ul>
</li>
</ol>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/09/grpc-要点a摘/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Howard">
      <meta itemprop="description" content="午夜向日葵，晌午夜光杯。跛者脚下路，屠夫腕上佛。">
      <meta itemprop="image" content="/images/avatar/P1070776.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="华氏温度">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/09/grpc-要点a摘/" itemprop="url">
                  grpc 要点å摘
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2019-12-09 23:14:26" itemprop="dateCreated datePublished" datetime="2019-12-09T23:14:26+08:00">2019-12-09</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/码文/" itemprop="url" rel="index"><span itemprop="name">码文</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/09/grpc-要点a摘/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/09/grpc-要点a摘/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>浅析入门<ol>
<li>RPC框架的目标<br>语言中立性原则构建微服务，不同服务采用不同的语言和技术，对于后端并发处理要求高的微服务，比较适合采用 Go 语言构建，而对于前端的 Web 界面，<br>则更适合 Java 和 JavaScript。因此，基于多语言的 RPC 框架来构建微服务，是一种比较好的技术选择。<br>例如API 服务编排层和后端的微服务之间采用 gRPC 进行通信<ul>
<li>远程服务调用更加简单、透明</li>
<li>屏蔽底层的传输方式（TCP 或者 UDP）</li>
<li>屏蔽序列化方式（XML/Json/ 二进制）</li>
<li>屏蔽通信细节</li>
<li>像调用本地接口一样调用远程的服务</li>
</ul>
</li>
<li>RPC 框架原理<ol>
<li>服务消费者通过微服务的动态代理，序列化请求消息，通过rpc client端发现请求消息，<br>通过底层网络传输到rpc server端</li>
<li>server端口拿到请求，反序列化请求消息，通过内部路由接口分发到对应逻辑方法中，<br>处理后结果再通过上面类似的方法进行返回。</li>
<li>结构类似于网络分层</li>
<li>上面说的目标里，屏蔽的几个方面，都抽象成了对应的层结构</li>
</ol>
</li>
<li>主流框架<ul>
<li>Google 的 gRPC</li>
<li>Apache（Facebook）的 Thrift</li>
<li>新浪的 Motan</li>
<li>阿里的 Dubbo （还支持服务治理的分布式服务框架）</li>
</ul>
</li>
<li>gRPC 简介<ul>
<li>高性能</li>
<li>开源</li>
<li>通用</li>
<li>面向服务端和移动端</li>
<li>基于 HTTP/2 </li>
</ul>
<ol>
<li>gRPC 概览<ul>
<li>目前主要支持C、Java 和 Go</li>
</ul>
</li>
<li>gRPC 特点<ul>
<li>语言中立，支持多种语言</li>
<li>基于 IDL 文件定义服务，通过 proto3 工具生成指定语言的数据结构、服务端接口以及客户端 Stub</li>
<li>通信协议基于标准的 HTTP/2 设计，支持双向流、消息头压缩、单 TCP 的多路复用、服务端推送等特性，<br>这些特性使得 gRPC 在移动端设备上更加省电和节省网络流量；</li>
<li>序列化支持 PB（Protocol Buffer）和 JSON，PB 是一种语言无关的高性能序列化框架，<br>基于 HTTP/2 + PB, 保障了 RPC 调用的高性能。</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
<li><p>gRPC 服务端</p>
<ol>
<li>服务端创建业务代码<br>定义服务proto（XXXX.proto）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">service Greeter &#123;</span><br><span class="line">  <span class="function">rpc <span class="title">SayHello</span> <span class="params">(HelloRequest)</span> <span class="title">returns</span> <span class="params">(HelloReply)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">message HelloReply &#123;</span><br><span class="line">  <span class="built_in">string</span> message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>定义服务端Service,并在50051端口开放服务，并把服务的实现加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void start() throws IOException &#123;</span><br><span class="line">    /* The port on which the server should run */</span><br><span class="line">    int port = 50051;</span><br><span class="line">    server = ServerBuilder.forPort(port)</span><br><span class="line">        .addService(new GreeterImpl())</span><br><span class="line">        .build()</span><br><span class="line">        .start();</span><br></pre></td></tr></table></figure>
<p>服务实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GreeterImpl</span> <span class="keyword">extends</span> <span class="title">GreeterGrpc</span>.<span class="title">GreeterImplBase</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(HelloRequest req, StreamObserver&lt;HelloReply&gt; responseObserver)</span> </span>&#123;</span><br><span class="line">      HelloReply reply = HelloReply.newBuilder().setMessage(<span class="string">"Hello "</span> + req.getName()).build();</span><br><span class="line">      responseObserver.onNext(reply);</span><br><span class="line">      responseObserver.onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>服务端创建流程<ol>
<li>创建 Netty HTTP/2 服务端</li>
<li>将需要调用的服务端接口实现类注册到内部的 Registry 中，RPC 调用时，可以根据 RPC 请求消息中的服务定义信息查询到服务接口实现类；</li>
<li>创建 gRPC Server，它是 gRPC 服务端的抽象，聚合了各种 Listener，用于 RPC 消息的统一调度和处理。</li>
</ol>
</li>
</ol>
</li>
<li>gRPC 服务端</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/08/spring-中的事务/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Howard">
      <meta itemprop="description" content="午夜向日葵，晌午夜光杯。跛者脚下路，屠夫腕上佛。">
      <meta itemprop="image" content="/images/avatar/P1070776.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="华氏温度">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/08/spring-中的事务/" itemprop="url">
                  spring 中的事务
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2019-12-08 10:46:58" itemprop="dateCreated datePublished" datetime="2019-12-08T10:46:58+08:00">2019-12-08</time>
            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/08/spring-中的事务/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/08/spring-中的事务/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="spring中的事务抽象"><a href="#spring中的事务抽象" class="headerlink" title="spring中的事务抽象"></a>spring中的事务抽象</h3><p>在spring中抽象帮助不同的数据框架ORM都能用相同的方式去做操作。  </p>
<ol>
<li>一致的事务模型<ul>
<li>操作数据的方式：JDBC Hibernate myBatis</li>
<li>DataSource JTA</li>
</ul>
</li>
<li><p>事务抽象类里的核心接口</p>
<ul>
<li>PlatformTransactionManager<ul>
<li>DataSourceTransactionManager</li>
<li>HibernateTransactionManager</li>
<li>JtaTransactionManager</li>
</ul>
</li>
<li>TransactionDefinitions(事务定义)<ul>
<li>Propagation(传播特性)</li>
<li>Isolation(隔离性)</li>
<li>Timeout(超时时间)</li>
<li>Read-only status(只读状态)<br>在PlatformTransactionManager中定义了commit rollback 方法实现统一事务提交，回滚操作。<br>通过getTransaction方法从TransactionDefinitions获取两个接口的参数TransactionStatus。</li>
</ul>
</li>
</ul>
<ol>
<li><p>事务的传播特性  </p>
<p>传播性|值|含<br>-|-|-<br>PROPAFGATION_REQUIRED|0|默认，有事务就用当前事务，没有就创建<br>PROPAFGATION_SUPPORTS|1|事务可有可无，不是必须的<br>PROPAFGATION_MANDARTORY|2|当前必须要有事务，没有就报错<br>PROPAFGATION_REQUIRES_NEW|3|无论是否有事务，都起新事务,之前的挂起.事务之间没有关联。事务之前结果不相互影响<br>PROPAFGATION_NOT_SUPPORTED|4|不支持事务，按照非事务方式运行<br>PROPAFGATION_NEVER|5|不支持事务，有事务就抛异常<br>PROPAFGATION_NESTED|6|内嵌事务，如果有事务，在当前事务中再起一个事务。<br>内嵌事务的结果（是否回滚），影响外部事务的执行。外部回滚，内部也回滚。内部抛异常，回滚了，外部不受影响。 </p>
</li>
<li><p>事务的隔离性  </p>
<p>默认-1 需要配置</p>
<p>隔离性|值|脏读|不可重复读|幻读<br>-|-|-|-|-<br>ISOLATION_READ_UNCOMMITTED|1|√|√|√<br>ISOLATION_READ_UNCOMMITTED|2|×|√|√<br>ISOLATION_READ_UNCOMMITTED|3|×|×|√<br>ISOLATION_READ_UNCOMMITTED|4|×|×|×</p>
</li>
</ol>
</li>
<li><p>编程式事务</p>
<ol>
<li>Transaction Template(基本简单方式)<ul>
<li>TransactionCallback</li>
<li>TransactionCallbackWithoutResult </li>
</ul>
</li>
<li>PlatformTransactionManager<ul>
<li>可以传入TransactionDefinittion进行定义</li>
</ul>
</li>
</ol>
</li>
<li><p>声明式事务  </p>
<ol>
<li>利用aop-proxy在目标方法上操作。  <ol>
<li>caller调用proxy代理，而不是直接调用目标方法</li>
<li>代理掉用Transaction Advisor，此时创建事务</li>
<li>代理掉用Transaction Advisor调用Custom Advisor</li>
<li>运行用户interceptors的before操作</li>
<li>调用目标方法，执行业务逻辑</li>
<li>执行后，返回结果，也可能没有结果返回void</li>
<li>Custom Advisor运行用户interceptors的after操作，返回给Transaction Advisor</li>
<li>Transaction Advisor事务操作成功commit，失败rollback</li>
<li>返回给proxy代理</li>
<li>返回给调用者 caller</li>
</ol>
</li>
<li>配置方式<ol>
<li>开启方式 注解 <code>@EnabelTransactionManagement</code> xml <code>&lt;tx:annotation-driver&gt;</code></li>
<li>配置<ul>
<li>proxyTargetClass true false 基于接口还是基于类</li>
<li>mode  Aop 默认java 可以改Spj</li>
<li>order 事务Aop拦截顺序，默认最低</li>
</ul>
</li>
<li>方法或类上加<code>@Transactional</code><ul>
<li>transactionManager</li>
<li>propagation</li>
<li>isolation</li>
<li>timeOut</li>
<li>readOnly</li>
<li>判断回滚策略（可配置某些异常类型回滚）</li>
</ul>
</li>
<li>一个没有配置<code>@Transactional</code>的方法，内部调用一个配置了<code>@Transactional</code>的方法<br>不会有事务的支持（外方法没有调用代理去做操作）。默认情 况下，spring aop同级调用失效，<br>因为同级无法创建代理对象，而事务是通过aop代理类实现的。<br>最简单是，把自己的实例注入进来，内部直接调用改成，用自己的实例<br>调用，因为自己的实例spring帮你创建了一个代理类，我们直接调用就行。也可以通过<br>AopContext.currentProxy()获取当前类的代理对象，再调用子方法，其实是增强后的的方法<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h5 id="spring声明式事务本质上是通过AOP来增强类的功能"><a href="#spring声明式事务本质上是通过AOP来增强类的功能" class="headerlink" title="spring声明式事务本质上是通过AOP来增强类的功能"></a>spring声明式事务本质上是通过AOP来增强类的功能</h5></li>
</ol>
<ul>
<li>before after</li>
<li>AOP创建动态代理<h5 id="REQUEST——NEW"><a href="#REQUEST——NEW" class="headerlink" title="REQUEST——NEW"></a>REQUEST——NEW</h5></li>
</ul>
</li>
</ol>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/07/spring-boot搭建问题全记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Howard">
      <meta itemprop="description" content="午夜向日葵，晌午夜光杯。跛者脚下路，屠夫腕上佛。">
      <meta itemprop="image" content="/images/avatar/P1070776.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="华氏温度">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/07/spring-boot搭建问题全记录/" itemprop="url">
                  spring boot搭建问题全记录
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2019-12-07 16:11:30" itemprop="dateCreated datePublished" datetime="2019-12-07T16:11:30+08:00">2019-12-07</time>
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/码文/" itemprop="url" rel="index"><span itemprop="name">码文</span></a></span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/07/spring-boot搭建问题全记录/#comments" itemprop="discussionUrl">
                
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2019/12/07/spring-boot搭建问题全记录/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>actuator/beans 访问返回 <code>Whitelabel Error Page This application has no explicit mapping for /error, so you are seeing this as a fallback.</code>错误<br> 你可以试试直接访问 <a href="http://localhost:8080/actuator/,返回" target="_blank" rel="noopener">http://localhost:8080/actuator/,返回</a><br> <code>{&quot;_links&quot;:{&quot;self&quot;:{&quot;href&quot;:&quot;http://localhost:8080/actuator&quot;,&quot;templated&quot;:false},&quot;health&quot;:{&quot;href&quot;:&quot;http://localhost:8080/actuator/health&quot;,&quot;templated&quot;:false},&quot;health-path&quot;:{&quot;href&quot;:&quot;http://localhost:8080/actuator/health/{*path}&quot;,&quot;templated&quot;:true},&quot;info&quot;:{&quot;href&quot;:&quot;http://localhost:8080/actuator/info&quot;,&quot;templated&quot;:false}}}</code><br> 可以看见默认开放的只有<code>health`</code>info<code>和</code>health-path<code>（看某个接口的health状态）。
 在application.properties文件里配置</code>management.endpoints.web.exposure.include=*` 可以根据自己需要打开某些接口。<br> 配置后可以发发现可以看项目中的很多信息，包括初始化的bean,caches-cache,caches,conditions,configprops,env,loggers,mappings等等</li>
<li></li>
<li></li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar/P1070776.jpg"
                alt="Howard" />
            
              <p class="site-author-name" itemprop="name">Howard</p>
              <p class="site-description motion-element" itemprop="description">午夜向日葵，晌午夜光杯。跛者脚下路，屠夫腕上佛。</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">19</span>
                    <span class="site-state-item-name">Artikel</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">Kategorien</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">32</span>
                    <span class="site-state-item-name">Tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/hizzyishome" target="_blank" title="GitHub" rel="external nofollow"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:hizzyzzh@hotmail.com" target="_blank" title="E-Mail" rel="external nofollow"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  
                </span>
              
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://mi.com/" title="MI" target="_blank">MI</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2016 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Howard</span>

  

  
</div>


  



  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" rel="external nofollow" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" rel="external nofollow" href="https://theme-next.org">NexT.Gemini</a> v6.3.0</div>





  <script src='https://unpkg.com/mermaid@8.4.8/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize("");
    }
  </script>


        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  



  
  



  
  



  
  







  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_sphere.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  

  
    <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
  

  





  





  










  





  

  

  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  


  
  

  

  

  

  

  

</body>
</html>
